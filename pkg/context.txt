# Context File Generated by STCP v1.0.0
# Generated on: 2025-07-03 04:27:02
# Source: .
# Total files: 19

================================================================================
# File: auto-pipeline.test.ts
# Size: 14567 bytes
================================================================================

import { Redis } from "../platforms/nodejs";
import { keygen, newHttpClient } from "./test-utils";

import { afterEach, describe, expect, test } from "bun:test";
import { ScriptLoadCommand } from "./commands/script_load";

const client = newHttpClient();

const { newKey, cleanup } = keygen();
afterEach(cleanup);

describe("Auto pipeline", () => {
  test("should execute all commands inside a Promise.all in a single pipeline", async () => {
    const persistentKey = newKey();
    const persistentKey2 = newKey();
    const persistentKey3 = newKey();
    const scriptHash = await new ScriptLoadCommand(["return 1"]).exec(client);

    const redis = Redis.fromEnv({
      latencyLogging: false,
      enableAutoPipelining: true,
    });
    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);

    // all the following commands are in a single pipeline call
    const result = await Promise.all([
      redis.append(newKey(), "hello"),
      redis.bitcount(newKey(), 0, 1),
      redis.bitop("and", newKey(), newKey()),
      redis.bitpos(newKey(), 1, 0),
      redis.dbsize(),
      redis.decr(newKey()),
      redis.decrby(newKey(), 1),
      redis.del(newKey()),
      redis.echo("hello"),
      redis.evalRo("return ARGV[1]", [], ["Hello"]),
      redis.eval("return ARGV[1]", [], ["Hello"]),
      redis.evalshaRo(scriptHash, [], ["Hello"]),
      redis.evalsha(scriptHash, [], ["Hello"]),
      redis.exists(newKey()),
      redis.expire(newKey(), 5),
      redis.expireat(newKey(), Math.floor(Date.now() / 1000) + 60),
      redis.flushall(),
      redis.flushdb(),
      redis.get(newKey()),
      redis.getbit(newKey(), 0),
      redis.getdel(newKey()),
      redis.getex(newKey()),
      redis.getset(newKey(), "hello"),
      redis.hdel(newKey(), "field"),
      redis.hexists(newKey(), "field"),
      redis.hexpire(newKey(), "field", 1),
      redis.hexpireat(newKey(), "field", Math.floor(Date.now() / 1000) + 60),
      redis.hexpiretime(newKey(), "field"),
      redis.httl(newKey(), "field"),
      redis.hpexpire(newKey(), "field", 1),
      redis.hpexpireat(newKey(), "field", Math.floor(Date.now() / 1000) + 60),
      redis.hpexpiretime(newKey(), "field"),
      redis.hpttl(newKey(), "field"),
      redis.hpersist(newKey(), "field"),
      redis.hget(newKey(), "field"),
      redis.hgetall(newKey()),
      redis.hincrby(newKey(), "field", 1),
      redis.hincrbyfloat(newKey(), "field", 1.5),
      redis.hkeys(newKey()),
      redis.hlen(newKey()),
      redis.hmget(newKey(), newKey()),
      redis.hmset(newKey(), { field: "field", value: "value" }),
      redis.hscan(newKey(), 0),
      redis.hset(newKey(), { field: "value" }),
      redis.hsetnx(newKey(), "field", "value"),
      redis.hstrlen(newKey(), "field"),
      redis.hvals(newKey()),
      redis.incr(newKey()),
      redis.incrby(newKey(), 1),
      redis.incrbyfloat(newKey(), 1.5),
      redis.keys("*"),
      redis.lindex(newKey(), 0),
      redis.linsert(newKey(), "before", "pivot", "value"),
      redis.llen(newKey()),
      redis.lmove(newKey(), newKey(), "left", "right"),
      redis.lpop(newKey()),
      redis.lpos(newKey(), "value"),
      redis.lpush(persistentKey, "element"),
      redis.lpushx(newKey(), "element1", "element2"),
      redis.lrange(newKey(), 0, 1),
      redis.lrem(newKey(), 1, "value"),
      redis.lset(persistentKey, 0, "value"),
      redis.ltrim(newKey(), 0, 1),
      redis.hrandfield(newKey()),
      redis.hrandfield(newKey(), 2),
      redis.hrandfield(newKey(), 3, true),
      redis.mget<[string, string]>(newKey(), newKey()),
      redis.mset({ key1: "value", key2: "value" }),
      redis.msetnx({ key3: "value", key4: "value" }),
      redis.persist(newKey()),
      redis.pexpire(newKey(), 1000),
      redis.pexpireat(newKey(), Date.now() + 1000),
      redis.ping(),
      redis.psetex(newKey(), 1, "value"),
      redis.pttl(newKey()),
      redis.publish("test", "hello"),
      redis.randomkey(),
      redis.rename(persistentKey, persistentKey2),
      redis.renamenx(persistentKey2, newKey()),
      redis.rpop(newKey()),
      redis.rpush(newKey(), "element1", "element2"),
      redis.rpushx(newKey(), "element1", "element2"),
      redis.sadd(newKey(), "memeber1", "member2"),
      redis.scan(0),
      redis.scard(newKey()),
      redis.sdiff(newKey()),
      redis.sdiffstore(newKey(), newKey()),
      redis.set(newKey(), "value"),
      redis.setbit(newKey(), 1, 1),
      redis.setex(newKey(), 1, "value"),
      redis.setnx(newKey(), "value"),
      redis.setrange(newKey(), 1, "value"),
      redis.sinter(newKey(), newKey()),
      redis.sinterstore(newKey(), newKey()),
      redis.sismember(newKey(), "member"),
      redis.smembers(newKey()),
      redis.smove(newKey(), newKey(), "member"),
      redis.spop(newKey()),
      redis.srandmember(newKey()),
      redis.srem(newKey(), "member"),
      redis.sscan(newKey(), 0),
      redis.strlen(newKey()),
      redis.sunion(newKey()),
      redis.sunionstore(newKey(), newKey()),
      redis.time(),
      redis.touch(newKey()),
      redis.ttl(newKey()),
      redis.type(newKey()),
      redis.unlink(newKey()),
      redis.zadd(newKey(), { score: 0, member: "member" }),
      redis.zcard(newKey()),
      redis.scriptExists(scriptHash),
      redis.scriptFlush({ async: true }),
      redis.scriptLoad("return 1"),
      redis.zcount(newKey(), 0, 1),
      redis.zincrby(newKey(), 1, "member"),
      redis.zinterstore(newKey(), 1, [newKey()]),
      redis.zlexcount(newKey(), "-", "+"),
      redis.zpopmax(newKey()),
      redis.zpopmin(newKey()),
      redis.zrange(newKey(), 0, 1),
      redis.zrank(newKey(), "member"),
      redis.zrem(newKey(), "member"),
      redis.zremrangebylex(newKey(), "-", "+"),
      redis.zremrangebyrank(newKey(), 0, 1),
      redis.zremrangebyscore(newKey(), 0, 1),
      redis.zrevrank(newKey(), "member"),
      redis.zscan(newKey(), 0),
      redis.zscore(newKey(), "member"),
      redis.zunionstore(newKey(), 1, [newKey()]),
      redis.zunion(1, [newKey()]),
      redis.json.set(persistentKey3, "$", { log: ["one", "two"] }),
      redis.json.arrappend(persistentKey3, "$.log", '"three"'),
      redis.json.merge(persistentKey3, "$.log", '"three"'),
    ]);
    expect(result).toBeTruthy();
    expect(result.length).toBe(134); // returns

    // @ts-expect-error pipelineCounter is not in type but accessible results
    expect(redis.pipelineCounter).toBe(1);
  });

  test("should group async requests with sync requests", async () => {
    const redis = Redis.fromEnv({
      latencyLogging: false,
      enableAutoPipelining: true,
    });
    await redis.flushdb();
    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);

    // following five commands are added to the pipeline
    void redis.del("baz");
    void redis.incr("baz");
    void redis.incr("baz");
    void redis.set("foo", "bar");
    void redis.incr("baz");

    // two get calls are added to the pipeline and pipeline
    // is executed since we called await
    const [fooValue, bazValue] = await Promise.all([redis.get("foo"), redis.get("baz")]);

    expect(fooValue).toBe("bar");
    expect(bazValue).toBe(3);
    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(1);
  });

  test("should execute a pipeline for each consecutive awaited command", async () => {
    const redis = Redis.fromEnv({
      latencyLogging: false,
      enableAutoPipelining: true,
    });

    const key1 = newKey();
    const key2 = newKey();

    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);

    await redis.flushdb();

    const res1 = await redis.incr(key1);
    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(1);

    const res2 = await redis.incr(key1);
    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(2);

    const res3 = await redis.set(key2, "bar");
    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(3);

    expect([res1, res2, res3]).toEqual([1, 2, "OK"]);
  });

  test("should execute a single pipeline for several commands inside Promise.all", async () => {
    const redis = Redis.fromEnv({
      latencyLogging: false,
      enableAutoPipelining: true,
    });
    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);

    const key1 = newKey();
    const key2 = newKey();

    const resArray = await Promise.all([
      redis.dbsize(),
      redis.incr(key1),
      redis.incr(key1),
      redis.set(key2, "bar"),
      redis.get(key2),
    ]);
    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(1);
    expect(resArray).toEqual([expect.any(Number), 1, 2, "OK", "bar"]);
  });

  test("should be able to utilize only redis functions 'use' like usual", async () => {
    const redis = Redis.fromEnv({
      latencyLogging: false,
      enableAutoPipelining: true,
    });
    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);

    let state = false;
    redis.use(async (req, next) => {
      state = true;
      return await next(req);
    });

    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);

    const a = await redis.incr("aeroplane");
    expect(a).toEqual(1);
    expect(state).toEqual(true);

    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(1);
  });

  test("should be able to utilize only redis functions 'multi' and 'pipeline' like usual", async () => {
    const redis = Redis.fromEnv({
      latencyLogging: false,
      enableAutoPipelining: true,
    });
    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);

    const pipe = redis.pipeline();
    pipe.incr("voila");
    pipe.incr("voila");
    const result = await pipe.exec();
    expect(result).toEqual([1, 2]);

    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);

    const transaction = redis.multi();
    transaction.incr("et voila");
    transaction.incr("et voila");
    const result_2 = await transaction.exec();
    expect(result_2).toEqual([1, 2]);

    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);
  });

  test("should be able to utilize only redis functions 'createScript' like usual", async () => {
    const redis = Redis.fromEnv({
      latencyLogging: false,
      enableAutoPipelining: true,
    });
    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);

    const script = redis.createScript("return ARGV[1];");

    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);

    const res = await script.eval([], ["Hello World"]);
    expect(res).toEqual("Hello World");

    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(1);
  });

  test("should handle JSON commands correctly", async () => {
    const redis = Redis.fromEnv({
      latencyLogging: false,
      enableAutoPipelining: true,
    });

    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(0);

    const res = await Promise.all([
      redis.set("foo1", "bar"),
      redis.json.set("baz1", "$", { hello: "world" }),
      redis.get("foo1"),
      redis.json.get("baz1"),
      redis.json.del("baz1"),
      redis.json.get("baz1"),
    ]);

    // @ts-expect-error pipelineCounter is not in type but accessible
    expect(redis.pipelineCounter).toBe(1);

    expect(res).toEqual(["OK", "OK", "bar", { hello: "world" }, 1, null]);
  });

  test("should throw errors granularly", async () => {
    // in this test, we have two methods being called parallel. both
    // use redis, but one of them has try/catch. when the request in
    // try fails, it shouldn't make the request in the parallel request
    // fail
    const redis = Redis.fromEnv({
      enableAutoPipelining: true,
    });

    const scriptLoadCommand = new ScriptLoadCommand(["redis.call('SET', 'foobar', 'foobar')"]);
    const scriptHash = await scriptLoadCommand.exec(client);
    await redis.scriptFlush();

    const methodOne = async () => {
      // method with try catch
      try {
        await redis.evalsha(scriptHash, [], []);
        throw new Error("test should have thrown in the command above");
      } catch (error_) {
        const error = error_ as Error;

        if (error.message.includes("NOSCRIPT")) {
          await scriptLoadCommand.exec(client);
          await redis.evalsha(scriptHash, [], []);
          return true;
        } else {
          throw new Error("incorrect error was thrown:", error);
        }
      }
    };

    const methodTwo = async () => {
      await redis.set("barfoo", "barfoo");
      return await redis.get("barfoo");
    };

    const [result1, result2] = await Promise.all([methodOne(), methodTwo()]);
    expect(result1).toBeTrue();
    expect(result2).toBe("barfoo");

    // first method executed correctly
    const result = await redis.get("foobar");
    expect(result).toBe("foobar");
  });

  describe("excluded commands", () => {
    test("should not exclude set", async () => {
      const redis = Redis.fromEnv();
      // @ts-expect-error pipelineCounter is not in type but accessible
      expect(redis.pipelineCounter).toBe(0);

      await redis.set("foo", "bar");

      // @ts-expect-error pipelineCounter is not in type but accessible
      expect(redis.pipelineCounter).toBe(1);
    });

    test("should exclude some commands", async () => {
      const redis = Redis.fromEnv({});

      // @ts-expect-error pipelineCounter is not in type but accessible
      expect(redis.pipelineCounter).toBe(0);

      await redis.scan(0, { count: 1 });
      await redis.keys("some-random-pattern");
      await redis.flushdb();
      await redis.flushall();
      await redis.dbsize();

      // @ts-expect-error pipelineCounter is not in type but accessible
      expect(redis.pipelineCounter).toBe(0);
    });
  });
});


================================================================================
# File: auto-pipeline.ts
# Size: 4224 bytes
================================================================================

import type { Command } from "./commands/command";
import { UpstashError } from "./error";
import type { UpstashResponse } from "./http";
import type { Pipeline } from "./pipeline";
import type { Redis } from "./redis";
import type { CommandArgs } from "./types";

// properties which are only available in redis
type redisOnly = Exclude<keyof Redis, keyof Pipeline>;

export const EXCLUDE_COMMANDS: Set<keyof Redis> = new Set([
  "scan",
  "keys",
  "flushdb",
  "flushall",
  "dbsize",
  "hscan",
  "hgetall",
  "hkeys",
  "lrange",
  "sscan",
  "smembers",
  "xrange",
  "xrevrange",
  "zscan",
  "zrange",
]);

export function createAutoPipelineProxy(_redis: Redis, json?: boolean): Redis {
  const redis = _redis as Redis & {
    autoPipelineExecutor: AutoPipelineExecutor;
  };

  if (!redis.autoPipelineExecutor) {
    redis.autoPipelineExecutor = new AutoPipelineExecutor(redis);
  }

  return new Proxy(redis, {
    get: (redis, command: "pipelineCounter" | keyof Pipeline | redisOnly) => {
      // return pipelineCounter of autoPipelineExecutor
      if (command === "pipelineCounter") {
        return redis.autoPipelineExecutor.pipelineCounter;
      }

      if (command === "json") {
        return createAutoPipelineProxy(redis, true);
      }

      const commandInRedisButNotPipeline =
        command in redis && !(command in redis.autoPipelineExecutor.pipeline);
      const isCommandExcluded = EXCLUDE_COMMANDS.has(command as keyof Redis);

      if (commandInRedisButNotPipeline || isCommandExcluded) {
        return redis[command as redisOnly];
      }

      // If the method is a function on the pipeline, wrap it with the executor logic
      const isFunction = json
        ? typeof redis.autoPipelineExecutor.pipeline.json[command as keyof Pipeline["json"]] ===
          "function"
        : typeof redis.autoPipelineExecutor.pipeline[command as keyof Pipeline] === "function";
      if (isFunction) {
        return (...args: CommandArgs<typeof Command>) => {
          // pass the function as a callback
          return redis.autoPipelineExecutor.withAutoPipeline((pipeline) => {
            if (json) {
              (pipeline.json[command as keyof Pipeline["json"]] as (...args: any) => unknown)(
                ...args
              );
            } else {
              (pipeline[command as keyof Pipeline] as (...args: any) => unknown)(...args);
            }
          });
        };
      }

      // if the property is not a function, a property of redis or "pipelineCounter"
      // simply return it from pipeline
      return redis.autoPipelineExecutor.pipeline[command as keyof Pipeline];
    },
  }) as Redis;
}

class AutoPipelineExecutor {
  private pipelinePromises = new WeakMap<Pipeline, Promise<unknown[]>>();
  private activePipeline: Pipeline | null = null;
  private indexInCurrentPipeline = 0;
  private redis: Redis;
  pipeline: Pipeline; // only to make sure that proxy can work
  pipelineCounter = 0; // to keep track of how many times a pipeline was executed

  constructor(redis: Redis) {
    this.redis = redis;
    this.pipeline = redis.pipeline();
  }

  async withAutoPipeline<T>(executeWithPipeline: (pipeline: Pipeline) => unknown): Promise<T> {
    const pipeline = this.activePipeline ?? this.redis.pipeline();

    if (!this.activePipeline) {
      this.activePipeline = pipeline;
      this.indexInCurrentPipeline = 0;
    }

    const index = this.indexInCurrentPipeline++;
    executeWithPipeline(pipeline);

    const pipelineDone = this.deferExecution().then(() => {
      if (!this.pipelinePromises.has(pipeline)) {
        const pipelinePromise = pipeline.exec({ keepErrors: true });
        this.pipelineCounter += 1;

        this.pipelinePromises.set(pipeline, pipelinePromise);
        this.activePipeline = null;
      }

      return this.pipelinePromises.get(pipeline)!;
    });

    const results = (await pipelineDone) as UpstashResponse<T>[];
    const commandResult = results[index];
    if (commandResult.error) {
      throw new UpstashError(`Command failed: ${commandResult.error}`);
    }
    return commandResult.result as T;
  }

  private async deferExecution() {
    await Promise.resolve();
    await Promise.resolve();
  }
}


================================================================================
# File: error.ts
# Size: 419 bytes
================================================================================

/**
 * Result of a bad request to upstash
 */
export class UpstashError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "UpstashError";
  }
}

export class UrlError extends Error {
  constructor(url: string) {
    super(
      `Upstash Redis client was passed an invalid URL. You should pass a URL starting with https. Received: "${url}". `
    );
    this.name = "UrlError";
  }
}


================================================================================
# File: http.test.ts
# Size: 2109 bytes
================================================================================

import { describe, test, expect } from "bun:test";
import { Redis } from "../platforms/nodejs";
import { serve } from "bun";

const MOCK_SERVER_PORT = 8080;
const SERVER_URL = `http://localhost:${MOCK_SERVER_PORT}`;

describe("http", () => {
  test("should terminate after sleeping 5 times", async () => {
    // init a cient which will always get errors
    const redis = new Redis({
      url: undefined,
      token: "non-existent",
      // set retry explicitly
      retry: {
        retries: 5,
        backoff: (retryCount) => Math.exp(retryCount) * 50,
      },
    });

    // get should take 4.287 seconds and terminate before the timeout.
    const throws = () => Promise.race([redis.get("foo"), new Promise((r) => setTimeout(r, 4500))]);

    // if the Promise.race doesn't throw, that means the retries took longer than 4.5s
    expect(throws).toThrow("fetch() URL is invalid");
  });

  test("should throw on request timeouts", async () => {
    const server = serve({
      async fetch(request) {
        const body = await request.text();

        if (body.includes("zed")) {
          return new Response(JSON.stringify({ result: '"zed-result"' }), { status: 200 });
        }

        await new Promise((resolve) => setTimeout(resolve, 5000));
        return new Response("Hello World");
      },
      port: MOCK_SERVER_PORT,
    });

    const redis = new Redis({
      url: SERVER_URL,
      token: "non-existent",
      signal: () => AbortSignal.timeout(1000), // set a timeout of 1 second
      // set to false since mock server doesn't return a response
      // for a pipeline. If you want to test pipelining, you can set it to true
      // and make the mock server return a pipeline response.
      enableAutoPipelining: false,
    });

    try {
      expect(redis.get("foo")).rejects.toThrow("The operation timed out.");
      expect(redis.get("bar")).rejects.toThrow("The operation timed out.");
      expect(redis.get("zed")).resolves.toBe("zed-result");
    } catch (error) {
      server.stop(true);
      throw error;
    } finally {
      server.stop(true);
    }
  });
});


================================================================================
# File: http.ts
# Size: 12335 bytes
================================================================================

import { UpstashError, UrlError } from "./error";
import type { Telemetry } from "./types";
import { mergeHeaders } from "./util";

type CacheSetting =
  | "default"
  | "force-cache"
  | "no-cache"
  | "no-store"
  | "only-if-cached"
  | "reload";

export type UpstashRequest = {
  path?: string[];
  /**
   * Request body will be serialized to json
   */
  body?: unknown;

  /**
   * Additional headers for the request
   */
  headers?: Record<string, string>;

  upstashSyncToken?: string;

  /**
   * Callback for handling streaming messages
   */
  onMessage?: (data: string) => void;

  /**
   * Whether this request expects a streaming response
   */
  isStreaming?: boolean;

  /**
   * Abort signal for the request
   */
  signal?: AbortSignal;
};
export type UpstashResponse<TResult> = { result?: TResult; error?: string };

export interface Requester {
  /**
   * When this flag is enabled, any subsequent commands issued by this client are guaranteed to observe the effects of all earlier writes submitted by the same client.
   */
  readYourWrites?: boolean;

  /**
   * This token is used to ensure that the client is in sync with the server. On each request, we send this token in the header, and the server will return a new token.
   */
  upstashSyncToken?: string;
  request: <TResult = unknown>(req: UpstashRequest) => Promise<UpstashResponse<TResult>>;
}

type ResultError = {
  result?: string | number | null | (string | number | null)[];
  error?: string;
};
export type RetryConfig =
  | false
  | {
      /**
       * The number of retries to attempt before giving up.
       *
       * @default 5
       */
      retries?: number;
      /**
       * A backoff function receives the current retry cound and returns a number in milliseconds to wait before retrying.
       *
       * @default
       * ```ts
       * Math.exp(retryCount) * 50
       * ```
       */
      backoff?: (retryCount: number) => number;
    };

export type Options = {
  backend?: string;
};

export type RequesterConfig = {
  /**
   * Configure the retry behaviour in case of network errors
   */
  retry?: RetryConfig;

  /**
   * Due to the nature of dynamic and custom data, it is possible to write data to redis that is not
   * valid json and will therefore cause errors when deserializing. This used to happen very
   * frequently with non-utf8 data, such as emojis.
   *
   * By default we will therefore encode the data as base64 on the server, before sending it to the
   * client. The client will then decode the base64 data and parse it as utf8.
   *
   * For very large entries, this can add a few milliseconds, so if you are sure that your data is
   * valid utf8, you can disable this behaviour by setting this option to false.
   *
   * Here's what the response body looks like:
   *
   * ```json
   * {
   *  result?: "base64-encoded",
   *  error?: string
   * }
   * ```
   *
   * @default "base64"
   */
  responseEncoding?: false | "base64";

  /**
   * Configure the cache behaviour
   * @default "no-store"
   */
  cache?: CacheSetting;
};

export type HttpClientConfig = {
  headers?: Record<string, string>;
  baseUrl: string;
  options?: Options;
  retry?: RetryConfig;
  agent?: any;
  signal?: AbortSignal | (() => AbortSignal);
  keepAlive?: boolean;

  /**
   * When this flag is enabled, any subsequent commands issued by this client are guaranteed to observe the effects of all earlier writes submitted by the same client.
   */
  readYourWrites?: boolean;
} & RequesterConfig;

export class HttpClient implements Requester {
  public baseUrl: string;
  public headers: Record<string, string>;

  public readonly options: {
    backend?: string;
    agent: any;
    signal?: HttpClientConfig["signal"];
    responseEncoding?: false | "base64";
    cache?: CacheSetting;
    keepAlive: boolean;
  };
  public readYourWrites: boolean;
  public upstashSyncToken = "";
  private hasCredentials: boolean;

  public readonly retry: {
    attempts: number;
    backoff: (retryCount: number) => number;
  };

  public constructor(config: HttpClientConfig) {
    this.options = {
      backend: config.options?.backend,
      agent: config.agent,
      responseEncoding: config.responseEncoding ?? "base64", // default to base64
      cache: config.cache,
      signal: config.signal,
      keepAlive: config.keepAlive ?? true,
    };
    this.upstashSyncToken = "";
    this.readYourWrites = config.readYourWrites ?? true;

    this.baseUrl = (config.baseUrl || "").replace(/\/$/, "");

    /**
     * regex to check if the baseUrl starts with http:// or https://
     * - `^` asserts the position at the start of the string.
     * - `[^\s/$.?#]` makes sure that the domain starts correctly;
     *   without white space, '/', '$', '.', '?' or '#'
     * - `.` matches any character except new line
     * - `[^\s]*` matches anything except white space
     * - `$` asserts the position at the end of the string.
     */
    const urlRegex = /^https?:\/\/[^\s#$./?].\S*$/;
    if (this.baseUrl && !urlRegex.test(this.baseUrl)) {
      throw new UrlError(this.baseUrl);
    }

    this.headers = {
      "Content-Type": "application/json",

      ...config.headers,
    };

    this.hasCredentials = Boolean(this.baseUrl && this.headers.authorization.split(" ")[1]);

    if (this.options.responseEncoding === "base64") {
      this.headers["Upstash-Encoding"] = "base64";
    }

    this.retry =
      typeof config.retry === "boolean" && !config.retry
        ? {
            attempts: 1,
            backoff: () => 0,
          }
        : {
            attempts: config.retry?.retries ?? 5,
            backoff: config.retry?.backoff ?? ((retryCount) => Math.exp(retryCount) * 50),
          };
  }

  public mergeTelemetry(telemetry: Telemetry): void {
    this.headers = merge(this.headers, "Upstash-Telemetry-Runtime", telemetry.runtime);
    this.headers = merge(this.headers, "Upstash-Telemetry-Platform", telemetry.platform);
    this.headers = merge(this.headers, "Upstash-Telemetry-Sdk", telemetry.sdk);
  }

  public async request<TResult>(req: UpstashRequest): Promise<UpstashResponse<TResult>> {
    const requestHeaders = mergeHeaders(this.headers, req.headers ?? {});
    const requestUrl = [this.baseUrl, ...(req.path ?? [])].join("/");
    const isEventStream = requestHeaders.Accept === "text/event-stream";

    const signal = req.signal ?? this.options.signal;
    const isSignalFunction = typeof signal === "function";

    const requestOptions: RequestInit & { backend?: string; agent?: any } = {
      //@ts-expect-error this should throw due to bun regression
      cache: this.options.cache,
      method: "POST",
      headers: requestHeaders,
      body: JSON.stringify(req.body),
      keepalive: this.options.keepAlive,
      agent: this.options.agent,
      signal: isSignalFunction ? signal() : signal,

      /**
       * Fastly specific
       */
      backend: this.options.backend,
    };

    if (!this.hasCredentials) {
      console.warn(
        "[Upstash Redis] Redis client was initialized without url or token." +
          " Failed to execute command."
      );
    }

    /**
     * We've recieved a new `upstash-sync-token` in the previous response. We use it in the next request to observe the effects of previous requests.
     */
    if (this.readYourWrites) {
      const newHeader = this.upstashSyncToken;
      this.headers["upstash-sync-token"] = newHeader;
    }

    let res: Response | null = null;
    let error: Error | null = null;
    for (let i = 0; i <= this.retry.attempts; i++) {
      try {
        res = await fetch(requestUrl, requestOptions);
        break;
      } catch (error_) {
        if (requestOptions.signal?.aborted && isSignalFunction) {
          throw error_;
        } else if (requestOptions.signal?.aborted) {
          const myBlob = new Blob([
            JSON.stringify({ result: requestOptions.signal.reason ?? "Aborted" }),
          ]);
          const myOptions = {
            status: 200,
            statusText: requestOptions.signal.reason ?? "Aborted",
          };
          res = new Response(myBlob, myOptions);
          break;
        }
        error = error_ as Error;

        // Only sleep if this is not the last attempt
        if (i < this.retry.attempts) {
          await new Promise((r) => setTimeout(r, this.retry.backoff(i)));
        }
      }
    }
    if (!res) {
      throw error ?? new Error("Exhausted all retries");
    }

    if (!res.ok) {
      const body = (await res.json()) as UpstashResponse<string>;
      throw new UpstashError(`${body.error}, command was: ${JSON.stringify(req.body)}`);
    }

    if (this.readYourWrites) {
      const headers = res.headers;
      this.upstashSyncToken = headers.get("upstash-sync-token") ?? "";
    }

    if (isEventStream && req && req.onMessage && res.body) {
      const reader = res.body.getReader();
      const decoder = new TextDecoder();

      // Start reading the stream in the background
      (async () => {
        try {
          while (true) {
            const { value, done } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split("\n");

            for (const line of lines) {
              if (line.startsWith("data: ")) {
                const data = line.slice(6);
                req.onMessage?.(data);
              }
            }
          }
        } catch (error) {
          if (error instanceof Error && error.name === "AbortError") {
            // Expected error during unsubscribe, ignore
          } else {
            console.error("Stream reading error:", error);
          }
        } finally {
          try {
            await reader.cancel();
          } catch {
            //ignore
          }
        }
      })();

      // Return success for streaming requests
      return { result: 1 as TResult };
    }

    const body = (await res.json()) as UpstashResponse<string>;

    /**
     * We save the new `upstash-sync-token` in the response header to use it in the next request.
     */
    if (this.readYourWrites) {
      const headers = res.headers;
      this.upstashSyncToken = headers.get("upstash-sync-token") ?? "";
    }

    if (this.options.responseEncoding === "base64") {
      if (Array.isArray(body)) {
        return body.map(({ result, error }) => ({
          result: decode(result),
          error,
        })) as UpstashResponse<TResult>;
      }
      const result = decode(body.result) as any;
      return { result, error: body.error };
    }

    return body as UpstashResponse<TResult>;
  }
}

function base64decode(b64: string): string {
  let dec = "";
  try {
    /**
     * Using only atob() is not enough because it doesn't work with unicode characters
     */
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for (let i = 0; i < size; i++) {
      // eslint-disable-next-line unicorn/prefer-code-point
      bytes[i] = binString.charCodeAt(i);
    }
    dec = new TextDecoder().decode(bytes);
  } catch {
    dec = b64;
  }
  return dec;
  // try {
  //   return decodeURIComponent(dec);
  // } catch {
  //   return dec;
  // }
}

function decode(raw: ResultError["result"]): ResultError["result"] {
  let result: any = undefined;
  switch (typeof raw) {
    case "undefined": {
      return raw;
    }

    case "number": {
      result = raw;
      break;
    }
    case "object": {
      // eslint-disable-next-line unicorn/prefer-ternary
      if (Array.isArray(raw)) {
        result = raw.map((v) =>
          typeof v === "string"
            ? base64decode(v)
            : Array.isArray(v)
              ? v.map((element) => decode(element))
              : v
        );
      } else {
        // If it's not an array it must be null
        // Apparently null is an object in javascript
        result = null;
      }
      break;
    }

    case "string": {
      result = raw === "OK" ? "OK" : base64decode(raw);
      break;
    }

    default: {
      break;
    }
  }

  return result;
}

function merge(obj: Record<string, string>, key: string, value?: string): Record<string, string> {
  if (!value) {
    return obj;
  }
  obj[key] = obj[key] ? [obj[key], value].join(",") : value;
  return obj;
}


================================================================================
# File: index.ts
# Size: 25 bytes
================================================================================

export * from "./error";


================================================================================
# File: pipeline.test.ts
# Size: 9294 bytes
================================================================================

import { Pipeline } from "./pipeline";
import { Redis } from "./redis";
import { keygen, newHttpClient, randomID } from "./test-utils";

import { afterEach, describe, expect, test } from "bun:test";
import { ScriptLoadCommand } from "./commands/script_load";

const client = newHttpClient();

const { newKey, cleanup } = keygen();
afterEach(cleanup);

describe("with destructuring", () => {
  test("correctly binds this", async () => {
    const { pipeline } = new Redis(client);
    const p = pipeline();

    const { echo, exec } = p;
    echo("Hello");

    const res = await exec();
    expect(res).toEqual(["Hello"]);
  });
});

describe("with single command", () => {
  test("works with multiple commands", async () => {
    const p = new Pipeline({ client });
    p.set(newKey(), randomID());
    const res = await p.exec();
    expect(res.length).toEqual(1);
    expect(res[0]).toEqual("OK");
  });
});

describe("when chaining in a for loop", () => {
  test("works", async () => {
    const key = newKey();
    const res = await new Pipeline({ client }).set(key, randomID()).get(key).exec();

    expect(res.length).toEqual(2);
  });
});

describe("when chaining inline", () => {
  test("works", async () => {
    const key = newKey();
    const p = new Pipeline({ client });
    for (let i = 0; i < 10; i++) {
      p.set(key, randomID());
    }

    const res = await p.exec();
    expect(res.length).toEqual(10);
  });
});

describe("when no commands were added", () => {
  test("throws", async () => {
    let hasThrown = false;
    await new Pipeline({ client }).exec().catch(() => {
      hasThrown = true;
    });
    expect(hasThrown).toBeTrue();
  });
});

describe("when length called", () => {
  test("before exec()", () => {
    const key = newKey();
    const p = new Pipeline({ client });
    for (let i = 0; i < 10; i++) {
      p.set(key, randomID());
    }
    expect(p.length()).toEqual(10);
  });

  test("after exec()", async () => {
    const key = newKey();
    const p = new Pipeline({ client });
    for (let i = 0; i < 10; i++) {
      p.set(key, randomID());
    }
    await p.exec();
    expect(p.length()).toEqual(10);
  });
});

describe("when one command throws an error", () => {
  test("throws", async () => {
    const p = new Pipeline({ client }).set("key", "value").hget("key", "field");
    let hasThrown = false;
    await p.exec().catch(() => {
      hasThrown = true;
    });
    expect(hasThrown).toBeTrue();
  });
});

describe("transaction", () => {
  test("works", async () => {
    const key = newKey();
    const value = randomID();
    const tx = new Pipeline({ client, multiExec: true });
    tx.set(key, value);
    tx.get(key);
    tx.del(key);

    const [ok, storedvalue, deleted] = await tx.exec<["OK", string, number]>();
    expect(ok).toEqual("OK");
    expect(storedvalue).toEqual(value);
    expect(deleted).toEqual(1);
  });
});
describe("use all the things", () => {
  test("works", async () => {
    const p = new Pipeline({ client });

    const persistentKey = newKey();
    const persistentKey2 = newKey();

    const scriptHash = await new ScriptLoadCommand(["return 1"]).exec(client);

    p.append(newKey(), "hello")
      .bitcount(newKey(), 0, 1)
      .bitfield(newKey())
      .set("u4", "#0", 15)
      .get("u4", "#0")
      .overflow("WRAP")
      .incrby("u4", "#0", 10)
      .exec()
      .bitop("and", newKey(), newKey())
      .bitpos(newKey(), 1, 0)
      .dbsize()
      .decr(newKey())
      .decrby(newKey(), 1)
      .del(newKey())
      .echo("hello")
      .evalRo("return ARGV[1]", [], ["Hello"])
      .eval("return ARGV[1]", [], ["Hello"])
      .evalshaRo(scriptHash, [], ["Hello"])
      .evalsha(scriptHash, [], ["Hello"])
      .exists(newKey())
      .expire(newKey(), 5)
      .expireat(newKey(), Math.floor(Date.now() / 1000) + 60)
      .flushall()
      .flushdb()
      .get(newKey())
      .getbit(newKey(), 0)
      .getdel(newKey())
      .getex(newKey())
      .getset(newKey(), "hello")
      .hdel(newKey(), "field")
      .hexists(newKey(), "field")
      .hexpire(newKey(), "field", 1)
      .hexpireat(newKey(), "field", Date.now() + 1000)
      .hexpiretime(newKey(), "field")
      .hpersist(newKey(), "field")
      .hpexpire(newKey(), "field", 1)
      .hpexpireat(newKey(), "field", 1)
      .hpexpiretime(newKey(), "field")
      .hpttl(newKey(), "field")
      .hget(newKey(), "field")
      .hgetall(newKey())
      .hincrby(newKey(), "field", 1)
      .hincrbyfloat(newKey(), "field", 1.5)
      .hkeys(newKey())
      .hlen(newKey())
      .hmget(newKey(), newKey())
      .hmset(newKey(), { field: "field", value: "value" })
      .hscan(newKey(), 0)
      .hset(newKey(), { field: "value" })
      .hsetnx(newKey(), "field", "value")
      .hstrlen(newKey(), "field")
      .httl(newKey(), "field")
      .hvals(newKey())
      .incr(newKey())
      .incrby(newKey(), 1)
      .incrbyfloat(newKey(), 1.5)
      .keys("*")
      .lindex(newKey(), 0)
      .linsert(newKey(), "before", "pivot", "value")
      .llen(newKey())
      .lmove(newKey(), newKey(), "left", "right")
      .lpop(newKey())
      .lpos(newKey(), "value")
      .lpush(persistentKey, "element")
      .lpushx(newKey(), "element1", "element2")
      .lrange(newKey(), 0, 1)
      .lrem(newKey(), 1, "value")
      .lset(persistentKey, 0, "value")
      .ltrim(newKey(), 0, 1)
      .hrandfield(newKey())
      .hrandfield(newKey(), 2)
      .hrandfield(newKey(), 3, true)
      .mget<[string, string]>(newKey(), newKey())
      .mset({ key1: "value", key2: "value" })
      .msetnx({ key3: "value", key4: "value" })
      .persist(newKey())
      .pexpire(newKey(), 1000)
      .pexpireat(newKey(), Date.now() + 1000)
      .ping()
      .psetex(newKey(), 1, "value")
      .pttl(newKey())
      .publish("test", "hello")
      .randomkey()
      .rename(persistentKey, persistentKey2)
      .renamenx(persistentKey2, newKey())
      .rpop(newKey())
      .rpush(newKey(), "element1", "element2")
      .rpushx(newKey(), "element1", "element2")
      .sadd(newKey(), "memeber1", "member2")
      .scan(0)
      .scard(newKey())
      .sdiff(newKey())
      .sdiffstore(newKey(), newKey())
      .set(newKey(), "value")
      .setbit(newKey(), 1, 1)
      .setex(newKey(), 1, "value")
      .setnx(newKey(), "value")
      .setrange(newKey(), 1, "value")
      .sinter(newKey(), newKey())
      .sinterstore(newKey(), newKey())
      .sismember(newKey(), "member")
      .smembers(newKey())
      .smove(newKey(), newKey(), "member")
      .spop(newKey())
      .srandmember(newKey())
      .srem(newKey(), "member")
      .sscan(newKey(), 0)
      .strlen(newKey())
      .sunion(newKey())
      .sunionstore(newKey(), newKey())
      .time()
      .touch(newKey())
      .ttl(newKey())
      .type(newKey())
      .unlink(newKey())
      .zadd(newKey(), { score: 0, member: "member" })
      .zcard(newKey())
      .scriptExists(scriptHash)
      .scriptFlush({ async: true })
      .scriptLoad("return 1")
      .zcount(newKey(), 0, 1)
      .zincrby(newKey(), 1, "member")
      .zinterstore(newKey(), 1, [newKey()])
      .zlexcount(newKey(), "-", "+")
      .zpopmax(newKey())
      .zpopmin(newKey())
      .zrange(newKey(), 0, 1)
      .zrank(newKey(), "member")
      .zrem(newKey(), "member")
      .zremrangebylex(newKey(), "-", "+")
      .zremrangebyrank(newKey(), 0, 1)
      .zremrangebyscore(newKey(), 0, 1)
      .zrevrank(newKey(), "member")
      .zscan(newKey(), 0)
      .zscore(newKey(), "member")
      .zunionstore(newKey(), 1, [newKey()])
      .zunion(1, [newKey()])
      .json.set(newKey(), "$", { hello: "world" });
    const res = await p.exec();
    expect(res.length).toEqual(133);
  });
});
describe("keep errors", () => {
  test("should return results in case of success", async () => {
    const p = new Pipeline({ client });
    p.set("foo", "1");
    p.set("bar", "2");
    p.getex("foo", { ex: 1 });
    p.get("bar");
    const results = await p.exec({ keepErrors: true });

    // errors are undefined
    for (const { error } of results) {
      expect(error).toBeUndefined();
    }
    expect(results[2].result).toBe(1);
    expect(results[3].result).toBe(2);
  });

  test("should throw without keepErrors", async () => {
    const p = new Pipeline({ client });
    p.set("foo", "1");
    p.set("bar", "2");
    p.evalsha("wrong-sha1", [], []);
    p.get("foo");
    p.get("bar");
    expect(() => p.exec()).toThrow(
      "Command 3 [ evalsha ] failed: NOSCRIPT No matching script. Please use EVAL."
    );
  });

  test("should return errors with keepErrors", async () => {
    const p = new Pipeline({ client });
    p.set("foo", "1");
    p.set("bar", "2");
    p.evalsha("wrong-sha1", [], []);
    p.getex("foo", { exat: 123 });
    p.get("bar");
    const results = await p.exec<[string, string, string, number, number]>({ keepErrors: true });

    expect(results[0].error).toBeUndefined();
    expect(results[1].error).toBeUndefined();
    expect(results[2].error).toBe("NOSCRIPT No matching script. Please use EVAL.");
    expect(results[3].error).toBeUndefined();
    expect(results[4].error).toBeUndefined();

    expect(results[2].result).toBeUndefined();
    expect(results[3].result).toBe(1);
    expect(results[4].result).toBe(2);
  });
});


================================================================================
# File: pipeline.ts
# Size: 45987 bytes
================================================================================

import type { Command, CommandOptions } from "./commands/command";
import { HRandFieldCommand } from "./commands/hrandfield";
import type {
  ScoreMember,
  SetCommandOptions,
  ZAddCommandOptions,
  ZRangeCommandOptions,
} from "./commands/mod";
import {
  AppendCommand,
  BitCountCommand,
  BitFieldCommand,
  BitOpCommand,
  BitPosCommand,
  CopyCommand,
  DBSizeCommand,
  DecrByCommand,
  DecrCommand,
  DelCommand,
  EchoCommand,
  EvalROCommand,
  EvalCommand,
  EvalshaROCommand,
  EvalshaCommand,
  ExistsCommand,
  ExpireAtCommand,
  ExpireCommand,
  FlushAllCommand,
  FlushDBCommand,
  GeoAddCommand,
  GeoDistCommand,
  GeoHashCommand,
  GeoPosCommand,
  GeoSearchCommand,
  GeoSearchStoreCommand,
  GetBitCommand,
  GetCommand,
  GetDelCommand,
  GetExCommand,
  GetRangeCommand,
  GetSetCommand,
  HDelCommand,
  HExistsCommand,
  HExpireCommand,
  HExpireAtCommand,
  HExpireTimeCommand,
  HTtlCommand,
  HPExpireCommand,
  HPExpireAtCommand,
  HPExpireTimeCommand,
  HPTtlCommand,
  HPersistCommand,
  HGetAllCommand,
  HGetCommand,
  HIncrByCommand,
  HIncrByFloatCommand,
  HKeysCommand,
  HLenCommand,
  HMGetCommand,
  HMSetCommand,
  HScanCommand,
  HSetCommand,
  HSetNXCommand,
  HStrLenCommand,
  HValsCommand,
  IncrByCommand,
  IncrByFloatCommand,
  IncrCommand,
  JsonArrAppendCommand,
  JsonArrIndexCommand,
  JsonArrInsertCommand,
  JsonArrLenCommand,
  JsonArrPopCommand,
  JsonArrTrimCommand,
  JsonClearCommand,
  JsonDelCommand,
  JsonForgetCommand,
  JsonGetCommand,
  JsonMergeCommand,
  JsonMGetCommand,
  JsonMSetCommand,
  JsonNumIncrByCommand,
  JsonNumMultByCommand,
  JsonObjKeysCommand,
  JsonObjLenCommand,
  JsonRespCommand,
  JsonSetCommand,
  JsonStrAppendCommand,
  JsonStrLenCommand,
  JsonToggleCommand,
  JsonTypeCommand,
  KeysCommand,
  LIndexCommand,
  LInsertCommand,
  LLenCommand,
  LMoveCommand,
  LPopCommand,
  LPosCommand,
  LPushCommand,
  LPushXCommand,
  LRangeCommand,
  LRemCommand,
  LSetCommand,
  LTrimCommand,
  LmPopCommand,
  MGetCommand,
  MSetCommand,
  MSetNXCommand,
  PExpireAtCommand,
  PExpireCommand,
  PSetEXCommand,
  PTtlCommand,
  PersistCommand,
  PfAddCommand,
  PfCountCommand,
  PfMergeCommand,
  PingCommand,
  PublishCommand,
  RPopCommand,
  RPushCommand,
  RPushXCommand,
  RandomKeyCommand,
  RenameCommand,
  RenameNXCommand,
  SAddCommand,
  SCardCommand,
  SDiffCommand,
  SDiffStoreCommand,
  SInterCommand,
  SInterStoreCommand,
  SIsMemberCommand,
  SMIsMemberCommand,
  SMembersCommand,
  SMoveCommand,
  SPopCommand,
  SRandMemberCommand,
  SRemCommand,
  SScanCommand,
  SUnionCommand,
  SUnionStoreCommand,
  ScanCommand,
  ScriptExistsCommand,
  ScriptFlushCommand,
  ScriptLoadCommand,
  SetBitCommand,
  SetCommand,
  SetExCommand,
  SetNxCommand,
  SetRangeCommand,
  StrLenCommand,
  TimeCommand,
  TouchCommand,
  TtlCommand,
  TypeCommand,
  UnlinkCommand,
  XAckCommand,
  XAddCommand,
  XAutoClaim,
  XClaimCommand,
  XDelCommand,
  XGroupCommand,
  XInfoCommand,
  XLenCommand,
  XPendingCommand,
  XRangeCommand,
  XReadCommand,
  XReadGroupCommand,
  XRevRangeCommand,
  XTrimCommand,
  ZAddCommand,
  ZCardCommand,
  ZCountCommand,
  ZIncrByCommand,
  ZInterStoreCommand,
  ZLexCountCommand,
  ZPopMaxCommand,
  ZPopMinCommand,
  ZRangeCommand,
  ZRankCommand,
  ZRemCommand,
  ZRemRangeByLexCommand,
  ZRemRangeByRankCommand,
  ZRemRangeByScoreCommand,
  ZRevRankCommand,
  ZScanCommand,
  ZScoreCommand,
  ZUnionCommand,
  ZUnionStoreCommand,
} from "./commands/mod";
import { ZDiffStoreCommand } from "./commands/zdiffstore";
import { ZMScoreCommand } from "./commands/zmscore";
import { UpstashError } from "./error";
import type { Requester, UpstashResponse } from "./http";
import type { CommandArgs } from "./types";

// Given a tuple of commands, returns a tuple of the response data of each command
type InferResponseData<T extends unknown[]> = {
  [K in keyof T]: T[K] extends Command<any, infer TData> ? TData : unknown;
};

interface ExecMethod<TCommands extends Command<any, any>[]> {
  /**
   * Send the pipeline request to upstash.
   *
   * Returns an array with the results of all pipelined commands.
   *
   * If all commands are statically chained from start to finish, types are inferred. You can still define a return type manually if necessary though:
   * ```ts
   * const p = redis.pipeline()
   * p.get("key")
   * const result = p.exec<[{ greeting: string }]>()
   * ```
   *
   * If one of the commands get an error, the whole pipeline fails. Alternatively, you can set the keepErrors option to true in order to get the errors individually.
   *
   * If keepErrors is set to true, a list of objects is returned where each object corresponds to a command and is of type: `{ result: unknown, error?: string }`.
   *
   * ```ts
   * const p = redis.pipeline()
   * p.get("key")
   *
   * const result = await p.exec({ keepErrors: true });
   * const getResult = result[0].result
   * const getError = result[0].error
   * ```
   */
  <
    TCommandResults extends unknown[] = [] extends TCommands
      ? unknown[]
      : InferResponseData<TCommands>,
  >(): Promise<TCommandResults>;
  <
    TCommandResults extends unknown[] = [] extends TCommands
      ? unknown[]
      : InferResponseData<TCommands>,
  >(options: {
    keepErrors: true;
  }): Promise<{ [K in keyof TCommandResults]: UpstashResponse<TCommandResults[K]> }>;
}

/**
 * Upstash REST API supports command pipelining to send multiple commands in
 * batch, instead of sending each command one by one and waiting for a response.
 * When using pipelines, several commands are sent using a single HTTP request,
 * and a single JSON array response is returned. Each item in the response array
 * corresponds to the command in the same order within the pipeline.
 *
 * **NOTE:**
 *
 * Execution of the pipeline is not atomic. Even though each command in
 * the pipeline will be executed in order, commands sent by other clients can
 * interleave with the pipeline.
 *
 * **Examples:**
 *
 * ```ts
 *  const p = redis.pipeline() // or redis.multi()
 * p.set("key","value")
 * p.get("key")
 * const res = await p.exec()
 * ```
 *
 * You can also chain commands together
 * ```ts
 * const p = redis.pipeline()
 * const res = await p.set("key","value").get("key").exec()
 * ```
 *
 * Return types are inferred if all commands are chained, but you can still
 * override the response type manually:
 * ```ts
 *  redis.pipeline()
 *   .set("key", { greeting: "hello"})
 *   .get("key")
 *   .exec<["OK", { greeting: string } ]>()
 *
 * ```
 */
export class Pipeline<TCommands extends Command<any, any>[] = []> {
  private client: Requester;
  private commands: TCommands;
  private commandOptions?: CommandOptions<any, any>;
  private multiExec: boolean;

  constructor(opts: {
    client: Requester;
    commandOptions?: CommandOptions<any, any>;
    multiExec?: boolean;
  }) {
    this.client = opts.client;

    this.commands = [] as unknown as TCommands; // the TCommands generic in the class definition is only used for carrying through chained command types and should never be explicitly set when instantiating the class
    this.commandOptions = opts.commandOptions;
    this.multiExec = opts.multiExec ?? false;

    if (this.commandOptions?.latencyLogging) {
      const originalExec = this.exec.bind(this);
      this.exec = async <
        TCommandResults extends unknown[] = [] extends TCommands
          ? unknown[]
          : InferResponseData<TCommands>,
      >(options?: {
        keepErrors: true;
      }): Promise<TCommandResults> => {
        const start = performance.now();
        const result = await (options ? originalExec(options) : originalExec());
        const end = performance.now();
        const loggerResult = (end - start).toFixed(2);
        // eslint-disable-next-line no-console
        console.log(
          `Latency for \u001B[38;2;19;185;39m${
            this.multiExec ? ["MULTI-EXEC"] : ["PIPELINE"].toString().toUpperCase()
          }\u001B[0m: \u001B[38;2;0;255;255m${loggerResult} ms\u001B[0m`
        );
        return result as TCommandResults;
      };
    }
  }

  exec: ExecMethod<TCommands> = async (options?: { keepErrors: true }) => {
    if (this.commands.length === 0) {
      throw new Error("Pipeline is empty");
    }
    const path = this.multiExec ? ["multi-exec"] : ["pipeline"];

    const res = (await this.client.request({
      path,
      body: Object.values(this.commands).map((c) => c.command),
    })) as UpstashResponse<any>[];

    return options?.keepErrors
      ? res.map(({ error, result }, i) => {
          return {
            error: error,
            result: this.commands[i].deserialize(result),
          };
        })
      : res.map(({ error, result }, i) => {
          if (error) {
            throw new UpstashError(
              `Command ${i + 1} [ ${this.commands[i].command[0]} ] failed: ${error}`
            );
          }

          return this.commands[i].deserialize(result);
        });
  };

  /**
   * Returns the length of pipeline before the execution
   */
  length(): number {
    return this.commands.length;
  }

  /**
   * Pushes a command into the pipeline and returns a chainable instance of the
   * pipeline
   */
  private chain<T>(command: Command<any, T>): Pipeline<[...TCommands, Command<any, T>]> {
    this.commands.push(command);
    return this as any; // TS thinks we're returning Pipeline<[]> here, because we're not creating a new instance of the class, hence the cast
  }

  /**
   * @see https://redis.io/commands/append
   */
  append = (...args: CommandArgs<typeof AppendCommand>) =>
    this.chain(new AppendCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/bitcount
   */
  bitcount = (...args: CommandArgs<typeof BitCountCommand>) =>
    this.chain(new BitCountCommand(args, this.commandOptions));

  /**
   * Returns an instance that can be used to execute `BITFIELD` commands on one key.
   *
   * @example
   * ```typescript
   * redis.set("mykey", 0);
   * const result = await redis.pipeline()
   *   .bitfield("mykey")
   *   .set("u4", 0, 16)
   *   .incr("u4", "#1", 1)
   *   .exec();
   * console.log(result); // [[0, 1]]
   * ```
   *
   * @see https://redis.io/commands/bitfield
   */
  bitfield = (...args: CommandArgs<typeof BitFieldCommand>) =>
    new BitFieldCommand(args, this.client, this.commandOptions, this.chain.bind(this));

  /**
   * @see https://redis.io/commands/bitop
   */
  bitop: {
    (
      op: "and" | "or" | "xor",
      destinationKey: string,
      sourceKey: string,
      ...sourceKeys: string[]
    ): Pipeline<[...TCommands, BitOpCommand]>;
    (op: "not", destinationKey: string, sourceKey: string): Pipeline<[...TCommands, BitOpCommand]>;
  } = (
    op: "and" | "or" | "xor" | "not",
    destinationKey: string,
    sourceKey: string,
    ...sourceKeys: string[]
  ) =>
    this.chain(
      new BitOpCommand([op as any, destinationKey, sourceKey, ...sourceKeys], this.commandOptions)
    );

  /**
   * @see https://redis.io/commands/bitpos
   */
  bitpos = (...args: CommandArgs<typeof BitPosCommand>) =>
    this.chain(new BitPosCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/copy
   */
  copy = (...args: CommandArgs<typeof CopyCommand>) =>
    this.chain(new CopyCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zdiffstore
   */
  zdiffstore = (...args: CommandArgs<typeof ZDiffStoreCommand>) =>
    this.chain(new ZDiffStoreCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/dbsize
   */
  dbsize = () => this.chain(new DBSizeCommand(this.commandOptions));

  /**
   * @see https://redis.io/commands/decr
   */
  decr = (...args: CommandArgs<typeof DecrCommand>) =>
    this.chain(new DecrCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/decrby
   */
  decrby = (...args: CommandArgs<typeof DecrByCommand>) =>
    this.chain(new DecrByCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/del
   */
  del = (...args: CommandArgs<typeof DelCommand>) =>
    this.chain(new DelCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/echo
   */
  echo = (...args: CommandArgs<typeof EchoCommand>) =>
    this.chain(new EchoCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/eval_ro
   */
  evalRo = <TArgs extends unknown[], TData = unknown>(
    ...args: [script: string, keys: string[], args: TArgs]
  ) => this.chain(new EvalROCommand<TArgs, TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/eval
   */
  eval = <TArgs extends unknown[], TData = unknown>(
    ...args: [script: string, keys: string[], args: TArgs]
  ) => this.chain(new EvalCommand<TArgs, TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/evalsha_ro
   */
  evalshaRo = <TArgs extends unknown[], TData = unknown>(
    ...args: [sha1: string, keys: string[], args: TArgs]
  ) => this.chain(new EvalshaROCommand<TArgs, TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/evalsha
   */
  evalsha = <TArgs extends unknown[], TData = unknown>(
    ...args: [sha1: string, keys: string[], args: TArgs]
  ) => this.chain(new EvalshaCommand<TArgs, TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/exists
   */
  exists = (...args: CommandArgs<typeof ExistsCommand>) =>
    this.chain(new ExistsCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/expire
   */
  expire = (...args: CommandArgs<typeof ExpireCommand>) =>
    this.chain(new ExpireCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/expireat
   */
  expireat = (...args: CommandArgs<typeof ExpireAtCommand>) =>
    this.chain(new ExpireAtCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/flushall
   */
  flushall = (args?: CommandArgs<typeof FlushAllCommand>) =>
    this.chain(new FlushAllCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/flushdb
   */
  flushdb = (...args: CommandArgs<typeof FlushDBCommand>) =>
    this.chain(new FlushDBCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/geoadd
   */
  geoadd = <TData>(...args: CommandArgs<typeof GeoAddCommand<TData>>) =>
    this.chain(new GeoAddCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/geodist
   */
  geodist = <TData>(...args: CommandArgs<typeof GeoDistCommand<TData>>) =>
    this.chain(new GeoDistCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/geopos
   */
  geopos = <TData>(...args: CommandArgs<typeof GeoPosCommand<TData>>) =>
    this.chain(new GeoPosCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/geohash
   */
  geohash = <TData>(...args: CommandArgs<typeof GeoHashCommand<TData>>) =>
    this.chain(new GeoHashCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/geosearch
   */
  geosearch = <TData>(...args: CommandArgs<typeof GeoSearchCommand<TData>>) =>
    this.chain(new GeoSearchCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/geosearchstore
   */
  geosearchstore = <TData>(...args: CommandArgs<typeof GeoSearchStoreCommand<TData>>) =>
    this.chain(new GeoSearchStoreCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/get
   */
  get = <TData>(...args: CommandArgs<typeof GetCommand>) =>
    this.chain(new GetCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/getbit
   */
  getbit = (...args: CommandArgs<typeof GetBitCommand>) =>
    this.chain(new GetBitCommand(args, this.commandOptions));
  /**
   * @see https://redis.io/commands/getdel
   */
  getdel = <TData>(...args: CommandArgs<typeof GetDelCommand>) =>
    this.chain(new GetDelCommand<TData>(args, this.commandOptions));
  /**
   * @see https://redis.io/commands/getex
   */
  getex = <TData>(...args: CommandArgs<typeof GetExCommand>) =>
    this.chain(new GetExCommand<TData>(args, this.commandOptions));
  /**
   * @see https://redis.io/commands/getrange
   */
  getrange = (...args: CommandArgs<typeof GetRangeCommand>) =>
    this.chain(new GetRangeCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/getset
   */
  getset = <TData>(key: string, value: TData) =>
    this.chain(new GetSetCommand<TData>([key, value], this.commandOptions));

  /**
   * @see https://redis.io/commands/hdel
   */
  hdel = (...args: CommandArgs<typeof HDelCommand>) =>
    this.chain(new HDelCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hexists
   */
  hexists = (...args: CommandArgs<typeof HExistsCommand>) =>
    this.chain(new HExistsCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hexpire
   */
  hexpire = (...args: CommandArgs<typeof HExpireCommand>) =>
    this.chain(new HExpireCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hexpireat
   */
  hexpireat = (...args: CommandArgs<typeof HExpireAtCommand>) =>
    this.chain(new HExpireAtCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hexpiretime
   */
  hexpiretime = (...args: CommandArgs<typeof HExpireTimeCommand>) =>
    this.chain(new HExpireTimeCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/httl
   */
  httl = (...args: CommandArgs<typeof HTtlCommand>) =>
    this.chain(new HTtlCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hpexpire
   */
  hpexpire = (...args: CommandArgs<typeof HPExpireCommand>) =>
    this.chain(new HPExpireCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hpexpireat
   */
  hpexpireat = (...args: CommandArgs<typeof HPExpireAtCommand>) =>
    this.chain(new HPExpireAtCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hpexpiretime
   */
  hpexpiretime = (...args: CommandArgs<typeof HPExpireTimeCommand>) =>
    this.chain(new HPExpireTimeCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hpttl
   */
  hpttl = (...args: CommandArgs<typeof HPTtlCommand>) =>
    this.chain(new HPTtlCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hpersist
   */
  hpersist = (...args: CommandArgs<typeof HPersistCommand>) =>
    this.chain(new HPersistCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hget
   */
  hget = <TData>(...args: CommandArgs<typeof HGetCommand>) =>
    this.chain(new HGetCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hgetall
   */
  hgetall = <TData extends Record<string, unknown>>(...args: CommandArgs<typeof HGetAllCommand>) =>
    this.chain(new HGetAllCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hincrby
   */
  hincrby = (...args: CommandArgs<typeof HIncrByCommand>) =>
    this.chain(new HIncrByCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hincrbyfloat
   */
  hincrbyfloat = (...args: CommandArgs<typeof HIncrByFloatCommand>) =>
    this.chain(new HIncrByFloatCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hkeys
   */
  hkeys = (...args: CommandArgs<typeof HKeysCommand>) =>
    this.chain(new HKeysCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hlen
   */
  hlen = (...args: CommandArgs<typeof HLenCommand>) =>
    this.chain(new HLenCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hmget
   */
  hmget = <TData extends Record<string, unknown>>(...args: CommandArgs<typeof HMGetCommand>) =>
    this.chain(new HMGetCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hmset
   */
  hmset = <TData>(key: string, kv: Record<string, TData>) =>
    this.chain(new HMSetCommand([key, kv], this.commandOptions));

  /**
   * @see https://redis.io/commands/hrandfield
   */
  hrandfield = <TData extends string | string[] | Record<string, unknown>>(
    key: string,
    count?: number,
    withValues?: boolean
  ) =>
    this.chain(new HRandFieldCommand<TData>([key, count, withValues] as any, this.commandOptions));

  /**
   * @see https://redis.io/commands/hscan
   */
  hscan = (...args: CommandArgs<typeof HScanCommand>) =>
    this.chain(new HScanCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hset
   */
  hset = <TData>(key: string, kv: Record<string, TData>) =>
    this.chain(new HSetCommand<TData>([key, kv], this.commandOptions));

  /**
   * @see https://redis.io/commands/hsetnx
   */
  hsetnx = <TData>(key: string, field: string, value: TData) =>
    this.chain(new HSetNXCommand<TData>([key, field, value], this.commandOptions));

  /**
   * @see https://redis.io/commands/hstrlen
   */
  hstrlen = (...args: CommandArgs<typeof HStrLenCommand>) =>
    this.chain(new HStrLenCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/hvals
   */
  hvals = (...args: CommandArgs<typeof HValsCommand>) =>
    this.chain(new HValsCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/incr
   */
  incr = (...args: CommandArgs<typeof IncrCommand>) =>
    this.chain(new IncrCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/incrby
   */
  incrby = (...args: CommandArgs<typeof IncrByCommand>) =>
    this.chain(new IncrByCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/incrbyfloat
   */
  incrbyfloat = (...args: CommandArgs<typeof IncrByFloatCommand>) =>
    this.chain(new IncrByFloatCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/keys
   */
  keys = (...args: CommandArgs<typeof KeysCommand>) =>
    this.chain(new KeysCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/lindex
   */
  lindex = (...args: CommandArgs<typeof LIndexCommand>) =>
    this.chain(new LIndexCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/linsert
   */
  linsert = <TData>(key: string, direction: "before" | "after", pivot: TData, value: TData) =>
    this.chain(new LInsertCommand<TData>([key, direction, pivot, value], this.commandOptions));

  /**
   * @see https://redis.io/commands/llen
   */
  llen = (...args: CommandArgs<typeof LLenCommand>) =>
    this.chain(new LLenCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/lmove
   */
  lmove = <TData = string>(...args: CommandArgs<typeof LMoveCommand>) =>
    this.chain(new LMoveCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/lpop
   */
  lpop = <TData>(...args: CommandArgs<typeof LPopCommand>) =>
    this.chain(new LPopCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/lmpop
   */
  lmpop = <TData>(...args: CommandArgs<typeof LmPopCommand>) =>
    this.chain(new LmPopCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/lpos
   */
  lpos = <TData>(...args: CommandArgs<typeof LPosCommand>) =>
    this.chain(new LPosCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/lpush
   */
  lpush = <TData>(key: string, ...elements: TData[]) =>
    this.chain(new LPushCommand<TData>([key, ...elements], this.commandOptions));

  /**
   * @see https://redis.io/commands/lpushx
   */
  lpushx = <TData>(key: string, ...elements: TData[]) =>
    this.chain(new LPushXCommand<TData>([key, ...elements], this.commandOptions));

  /**
   * @see https://redis.io/commands/lrange
   */
  lrange = <TResult = string>(...args: CommandArgs<typeof LRangeCommand>) =>
    this.chain(new LRangeCommand<TResult>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/lrem
   */
  lrem = <TData>(key: string, count: number, value: TData) =>
    this.chain(new LRemCommand([key, count, value], this.commandOptions));

  /**
   * @see https://redis.io/commands/lset
   */
  lset = <TData>(key: string, index: number, value: TData) =>
    this.chain(new LSetCommand([key, index, value], this.commandOptions));

  /**
   * @see https://redis.io/commands/ltrim
   */
  ltrim = (...args: CommandArgs<typeof LTrimCommand>) =>
    this.chain(new LTrimCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/mget
   */
  mget = <TData extends unknown[]>(...args: CommandArgs<typeof MGetCommand>) =>
    this.chain(new MGetCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/mset
   */
  mset = <TData>(kv: Record<string, TData>) =>
    this.chain(new MSetCommand<TData>([kv], this.commandOptions));

  /**
   * @see https://redis.io/commands/msetnx
   */
  msetnx = <TData>(kv: Record<string, TData>) =>
    this.chain(new MSetNXCommand<TData>([kv], this.commandOptions));

  /**
   * @see https://redis.io/commands/persist
   */
  persist = (...args: CommandArgs<typeof PersistCommand>) =>
    this.chain(new PersistCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/pexpire
   */
  pexpire = (...args: CommandArgs<typeof PExpireCommand>) =>
    this.chain(new PExpireCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/pexpireat
   */
  pexpireat = (...args: CommandArgs<typeof PExpireAtCommand>) =>
    this.chain(new PExpireAtCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/pfadd
   */
  pfadd = (...args: CommandArgs<typeof PfAddCommand>) =>
    this.chain(new PfAddCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/pfcount
   */
  pfcount = (...args: CommandArgs<typeof PfCountCommand>) =>
    this.chain(new PfCountCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/pfmerge
   */
  pfmerge = (...args: CommandArgs<typeof PfMergeCommand>) =>
    this.chain(new PfMergeCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/ping
   */
  ping = (args?: CommandArgs<typeof PingCommand>) =>
    this.chain(new PingCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/psetex
   */
  psetex = <TData>(key: string, ttl: number, value: TData) =>
    this.chain(new PSetEXCommand<TData>([key, ttl, value], this.commandOptions));

  /**
   * @see https://redis.io/commands/pttl
   */
  pttl = (...args: CommandArgs<typeof PTtlCommand>) =>
    this.chain(new PTtlCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/publish
   */
  publish = (...args: CommandArgs<typeof PublishCommand>) =>
    this.chain(new PublishCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/randomkey
   */
  randomkey = () => this.chain(new RandomKeyCommand(this.commandOptions));

  /**
   * @see https://redis.io/commands/rename
   */
  rename = (...args: CommandArgs<typeof RenameCommand>) =>
    this.chain(new RenameCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/renamenx
   */
  renamenx = (...args: CommandArgs<typeof RenameNXCommand>) =>
    this.chain(new RenameNXCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/rpop
   */
  rpop = <TData = string>(...args: CommandArgs<typeof RPopCommand>) =>
    this.chain(new RPopCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/rpush
   */
  rpush = <TData>(key: string, ...elements: TData[]) =>
    this.chain(new RPushCommand([key, ...elements], this.commandOptions));

  /**
   * @see https://redis.io/commands/rpushx
   */
  rpushx = <TData>(key: string, ...elements: TData[]) =>
    this.chain(new RPushXCommand([key, ...elements], this.commandOptions));

  /**
   * @see https://redis.io/commands/sadd
   */
  sadd = <TData>(key: string, member: TData, ...members: TData[]) =>
    this.chain(new SAddCommand<TData>([key, member, ...members], this.commandOptions));

  /**
   * @see https://redis.io/commands/scan
   */
  scan = (...args: CommandArgs<typeof ScanCommand>) =>
    this.chain(new ScanCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/scard
   */
  scard = (...args: CommandArgs<typeof SCardCommand>) =>
    this.chain(new SCardCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/script-exists
   */
  scriptExists = (...args: CommandArgs<typeof ScriptExistsCommand>) =>
    this.chain(new ScriptExistsCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/script-flush
   */
  scriptFlush = (...args: CommandArgs<typeof ScriptFlushCommand>) =>
    this.chain(new ScriptFlushCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/script-load
   */
  scriptLoad = (...args: CommandArgs<typeof ScriptLoadCommand>) =>
    this.chain(new ScriptLoadCommand(args, this.commandOptions));
  /*)*
   * @see https://redis.io/commands/sdiff
   */
  sdiff = (...args: CommandArgs<typeof SDiffCommand>) =>
    this.chain(new SDiffCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/sdiffstore
   */
  sdiffstore = (...args: CommandArgs<typeof SDiffStoreCommand>) =>
    this.chain(new SDiffStoreCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/set
   */
  set = <TData>(key: string, value: TData, opts?: SetCommandOptions) =>
    this.chain(new SetCommand<TData>([key, value, opts], this.commandOptions));

  /**
   * @see https://redis.io/commands/setbit
   */
  setbit = (...args: CommandArgs<typeof SetBitCommand>) =>
    this.chain(new SetBitCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/setex
   */
  setex = <TData>(key: string, ttl: number, value: TData) =>
    this.chain(new SetExCommand<TData>([key, ttl, value], this.commandOptions));

  /**
   * @see https://redis.io/commands/setnx
   */
  setnx = <TData>(key: string, value: TData) =>
    this.chain(new SetNxCommand<TData>([key, value], this.commandOptions));

  /**
   * @see https://redis.io/commands/setrange
   */
  setrange = (...args: CommandArgs<typeof SetRangeCommand>) =>
    this.chain(new SetRangeCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/sinter
   */
  sinter = (...args: CommandArgs<typeof SInterCommand>) =>
    this.chain(new SInterCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/sinterstore
   */
  sinterstore = (...args: CommandArgs<typeof SInterStoreCommand>) =>
    this.chain(new SInterStoreCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/sismember
   */
  sismember = <TData>(key: string, member: TData) =>
    this.chain(new SIsMemberCommand<TData>([key, member], this.commandOptions));

  /**
   * @see https://redis.io/commands/smembers
   */
  smembers = <TData extends unknown[] = string[]>(...args: CommandArgs<typeof SMembersCommand>) =>
    this.chain(new SMembersCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/smismember
   */
  smismember = <TMembers extends unknown[]>(key: string, members: TMembers) =>
    this.chain(new SMIsMemberCommand<TMembers>([key, members], this.commandOptions));

  /**
   * @see https://redis.io/commands/smove
   */
  smove = <TData>(source: string, destination: string, member: TData) =>
    this.chain(new SMoveCommand<TData>([source, destination, member], this.commandOptions));

  /**
   * @see https://redis.io/commands/spop
   */
  spop = <TData>(...args: CommandArgs<typeof SPopCommand>) =>
    this.chain(new SPopCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/srandmember
   */
  srandmember = <TData>(...args: CommandArgs<typeof SRandMemberCommand>) =>
    this.chain(new SRandMemberCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/srem
   */
  srem = <TData>(key: string, ...members: TData[]) =>
    this.chain(new SRemCommand<TData>([key, ...members], this.commandOptions));

  /**
   * @see https://redis.io/commands/sscan
   */
  sscan = (...args: CommandArgs<typeof SScanCommand>) =>
    this.chain(new SScanCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/strlen
   */
  strlen = (...args: CommandArgs<typeof StrLenCommand>) =>
    this.chain(new StrLenCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/sunion
   */
  sunion = (...args: CommandArgs<typeof SUnionCommand>) =>
    this.chain(new SUnionCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/sunionstore
   */
  sunionstore = (...args: CommandArgs<typeof SUnionStoreCommand>) =>
    this.chain(new SUnionStoreCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/time
   */
  time = () => this.chain(new TimeCommand(this.commandOptions));

  /**
   * @see https://redis.io/commands/touch
   */
  touch = (...args: CommandArgs<typeof TouchCommand>) =>
    this.chain(new TouchCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/ttl
   */
  ttl = (...args: CommandArgs<typeof TtlCommand>) =>
    this.chain(new TtlCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/type
   */
  type = (...args: CommandArgs<typeof TypeCommand>) =>
    this.chain(new TypeCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/unlink
   */
  unlink = (...args: CommandArgs<typeof UnlinkCommand>) =>
    this.chain(new UnlinkCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zadd
   */
  zadd = <TData>(
    ...args:
      | [key: string, scoreMember: ScoreMember<TData>, ...scoreMemberPairs: ScoreMember<TData>[]]
      | [
          key: string,
          opts: ZAddCommandOptions,
          ...scoreMemberPairs: [ScoreMember<TData>, ...ScoreMember<TData>[]],
        ]
  ) => {
    if ("score" in args[1]) {
      return this.chain(
        new ZAddCommand<TData>([args[0], args[1], ...(args.slice(2) as any)], this.commandOptions)
      );
    }

    return this.chain(
      new ZAddCommand<TData>(
        [args[0], args[1] as any, ...(args.slice(2) as any)],
        this.commandOptions
      )
    );
  };

  /**
   * @see https://redis.io/commands/xadd
   */
  xadd = (...args: CommandArgs<typeof XAddCommand>) =>
    this.chain(new XAddCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xack
   */
  xack = (...args: CommandArgs<typeof XAckCommand>) =>
    this.chain(new XAckCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xdel
   */
  xdel = (...args: CommandArgs<typeof XDelCommand>) =>
    this.chain(new XDelCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xgroup
   */
  xgroup = (...args: CommandArgs<typeof XGroupCommand>) =>
    this.chain(new XGroupCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xread
   */
  xread = (...args: CommandArgs<typeof XReadCommand>) =>
    this.chain(new XReadCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xreadgroup
   */
  xreadgroup = (...args: CommandArgs<typeof XReadGroupCommand>) =>
    this.chain(new XReadGroupCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xinfo
   */
  xinfo = (...args: CommandArgs<typeof XInfoCommand>) =>
    this.chain(new XInfoCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xlen
   */
  xlen = (...args: CommandArgs<typeof XLenCommand>) =>
    this.chain(new XLenCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xpending
   */
  xpending = (...args: CommandArgs<typeof XPendingCommand>) =>
    this.chain(new XPendingCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xclaim
   */
  xclaim = (...args: CommandArgs<typeof XClaimCommand>) =>
    this.chain(new XClaimCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xautoclaim
   */
  xautoclaim = (...args: CommandArgs<typeof XAutoClaim>) =>
    this.chain(new XAutoClaim(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xtrim
   */
  xtrim = (...args: CommandArgs<typeof XTrimCommand>) =>
    this.chain(new XTrimCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xrange
   */
  xrange = (...args: CommandArgs<typeof XRangeCommand>) =>
    this.chain(new XRangeCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/xrevrange
   */
  xrevrange = (...args: CommandArgs<typeof XRevRangeCommand>) =>
    this.chain(new XRevRangeCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zcard
   */
  zcard = (...args: CommandArgs<typeof ZCardCommand>) =>
    this.chain(new ZCardCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zcount
   */
  zcount = (...args: CommandArgs<typeof ZCountCommand>) =>
    this.chain(new ZCountCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zincrby
   */
  zincrby = <TData>(key: string, increment: number, member: TData) =>
    this.chain(new ZIncrByCommand<TData>([key, increment, member], this.commandOptions));

  /**
   * @see https://redis.io/commands/zinterstore
   */
  zinterstore = (...args: CommandArgs<typeof ZInterStoreCommand>) =>
    this.chain(new ZInterStoreCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zlexcount
   */
  zlexcount = (...args: CommandArgs<typeof ZLexCountCommand>) =>
    this.chain(new ZLexCountCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zmscore
   */
  zmscore = (...args: CommandArgs<typeof ZMScoreCommand>) =>
    this.chain(new ZMScoreCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zpopmax
   */
  zpopmax = <TData>(...args: CommandArgs<typeof ZPopMaxCommand>) =>
    this.chain(new ZPopMaxCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zpopmin
   */
  zpopmin = <TData>(...args: CommandArgs<typeof ZPopMinCommand>) =>
    this.chain(new ZPopMinCommand<TData>(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zrange
   */
  zrange = <TData extends unknown[]>(
    ...args:
      | [key: string, min: number, max: number, opts?: ZRangeCommandOptions]
      | [
          key: string,
          min: `(${string}` | `[${string}` | "-" | "+",
          max: `(${string}` | `[${string}` | "-" | "+",
          opts: { byLex: true } & ZRangeCommandOptions,
        ]
      | [
          key: string,
          min: number | `(${number}` | "-inf" | "+inf",
          max: number | `(${number}` | "-inf" | "+inf",
          opts: { byScore: true } & ZRangeCommandOptions,
        ]
  ) => this.chain(new ZRangeCommand<TData>(args as any, this.commandOptions));

  /**
   * @see https://redis.io/commands/zrank
   */
  zrank = <TData>(key: string, member: TData) =>
    this.chain(new ZRankCommand<TData>([key, member], this.commandOptions));

  /**
   * @see https://redis.io/commands/zrem
   */
  zrem = <TData>(key: string, ...members: TData[]) =>
    this.chain(new ZRemCommand<TData>([key, ...members], this.commandOptions));

  /**
   * @see https://redis.io/commands/zremrangebylex
   */
  zremrangebylex = (...args: CommandArgs<typeof ZRemRangeByLexCommand>) =>
    this.chain(new ZRemRangeByLexCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zremrangebyrank
   */
  zremrangebyrank = (...args: CommandArgs<typeof ZRemRangeByRankCommand>) =>
    this.chain(new ZRemRangeByRankCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zremrangebyscore
   */
  zremrangebyscore = (...args: CommandArgs<typeof ZRemRangeByScoreCommand>) =>
    this.chain(new ZRemRangeByScoreCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zrevrank
   */
  zrevrank = <TData>(key: string, member: TData) =>
    this.chain(new ZRevRankCommand<TData>([key, member], this.commandOptions));

  /**
   * @see https://redis.io/commands/zscan
   */
  zscan = (...args: CommandArgs<typeof ZScanCommand>) =>
    this.chain(new ZScanCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zscore
   */
  zscore = <TData>(key: string, member: TData) =>
    this.chain(new ZScoreCommand<TData>([key, member], this.commandOptions));

  /**
   * @see https://redis.io/commands/zunionstore
   */
  zunionstore = (...args: CommandArgs<typeof ZUnionStoreCommand>) =>
    this.chain(new ZUnionStoreCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/zunion
   */
  zunion = (...args: CommandArgs<typeof ZUnionCommand>) =>
    this.chain(new ZUnionCommand(args, this.commandOptions));

  /**
   * @see https://redis.io/commands/?group=json
   */
  get json() {
    return {
      /**
       * @see https://redis.io/commands/json.arrappend
       */
      arrappend: (...args: CommandArgs<typeof JsonArrAppendCommand>) =>
        this.chain(new JsonArrAppendCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.arrindex
       */
      arrindex: (...args: CommandArgs<typeof JsonArrIndexCommand>) =>
        this.chain(new JsonArrIndexCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.arrinsert
       */
      arrinsert: (...args: CommandArgs<typeof JsonArrInsertCommand>) =>
        this.chain(new JsonArrInsertCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.arrlen
       */
      arrlen: (...args: CommandArgs<typeof JsonArrLenCommand>) =>
        this.chain(new JsonArrLenCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.arrpop
       */
      arrpop: (...args: CommandArgs<typeof JsonArrPopCommand>) =>
        this.chain(new JsonArrPopCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.arrtrim
       */
      arrtrim: (...args: CommandArgs<typeof JsonArrTrimCommand>) =>
        this.chain(new JsonArrTrimCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.clear
       */
      clear: (...args: CommandArgs<typeof JsonClearCommand>) =>
        this.chain(new JsonClearCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.del
       */
      del: (...args: CommandArgs<typeof JsonDelCommand>) =>
        this.chain(new JsonDelCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.forget
       */
      forget: (...args: CommandArgs<typeof JsonForgetCommand>) =>
        this.chain(new JsonForgetCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.get
       */
      get: (...args: CommandArgs<typeof JsonGetCommand>) =>
        this.chain(new JsonGetCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.merge
       */
      merge: (...args: CommandArgs<typeof JsonMergeCommand>) =>
        this.chain(new JsonMergeCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.mget
       */
      mget: (...args: CommandArgs<typeof JsonMGetCommand>) =>
        this.chain(new JsonMGetCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.mset
       */
      mset: (...args: CommandArgs<typeof JsonMSetCommand>) =>
        this.chain(new JsonMSetCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.numincrby
       */
      numincrby: (...args: CommandArgs<typeof JsonNumIncrByCommand>) =>
        this.chain(new JsonNumIncrByCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.nummultby
       */
      nummultby: (...args: CommandArgs<typeof JsonNumMultByCommand>) =>
        this.chain(new JsonNumMultByCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.objkeys
       */
      objkeys: (...args: CommandArgs<typeof JsonObjKeysCommand>) =>
        this.chain(new JsonObjKeysCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.objlen
       */
      objlen: (...args: CommandArgs<typeof JsonObjLenCommand>) =>
        this.chain(new JsonObjLenCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.resp
       */
      resp: (...args: CommandArgs<typeof JsonRespCommand>) =>
        this.chain(new JsonRespCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.set
       */
      set: (...args: CommandArgs<typeof JsonSetCommand>) =>
        this.chain(new JsonSetCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.strappend
       */
      strappend: (...args: CommandArgs<typeof JsonStrAppendCommand>) =>
        this.chain(new JsonStrAppendCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.strlen
       */
      strlen: (...args: CommandArgs<typeof JsonStrLenCommand>) =>
        this.chain(new JsonStrLenCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.toggle
       */
      toggle: (...args: CommandArgs<typeof JsonToggleCommand>) =>
        this.chain(new JsonToggleCommand(args, this.commandOptions)),

      /**
       * @see https://redis.io/commands/json.type
       */
      type: (...args: CommandArgs<typeof JsonTypeCommand>) =>
        this.chain(new JsonTypeCommand(args, this.commandOptions)),
    };
  }
}


================================================================================
# File: read-your-writes.test.ts
# Size: 4636 bytes
================================================================================

import { keygen, newHttpClient } from "./test-utils";

import { afterAll, describe, expect, test } from "bun:test";

import { Redis as PublicRedis } from "../platforms/nodejs";
import { SetCommand } from "./commands/set";
import { Redis } from "./redis";

const client = newHttpClient();
const { cleanup } = keygen();
afterAll(cleanup);
describe("Read Your Writes Feature", () => {
  test("successfully retrieves Upstash-Sync-Token in the response header and updates local state", async () => {
    const initialSync = client.upstashSyncToken;
    await new SetCommand(["key", "value"]).exec(client);
    const updatedSync = client.upstashSyncToken;
    await new SetCommand(["key", "value"]).exec(client);

    expect(updatedSync).not.toEqual(initialSync);
  });

  test("succesfully updates sync state with pipeline", async () => {
    const initialSync = client.upstashSyncToken;

    const { pipeline } = new Redis(client);
    const p = pipeline();

    p.set("key1", "value1");
    p.set("key2", "value2");
    p.set("key3", "value3");

    await p.exec();

    const updatedSync = client.upstashSyncToken;

    expect(initialSync).not.toEqual(updatedSync);
  });

  test("updates after each element of promise.all", async () => {
    let currentSync = client.upstashSyncToken;

    const promises = Array.from({ length: 3 }, (_, i) =>
      new SetCommand([`key${i}`, `value${i}`]).exec(client).then(() => {
        expect(client.upstashSyncToken).not.toEqual(currentSync);
        currentSync = client.upstashSyncToken;
      })
    );

    await Promise.all(promises);
  });

  test("updates after successful lua script call", async () => {
    const s = `redis.call('SET', 'mykey', 'myvalue')
		return 1
		`;

    const initialSync = client.upstashSyncToken;

    const redis = new Redis(client);
    const script = redis.createScript(s);

    await script.exec([], []);

    const updatedSync = client.upstashSyncToken;

    expect(updatedSync).not.toEqual(initialSync);
  });

  test("should not update the sync state in case of Redis client with manuel HTTP client and opt-out ryw", async () => {
    const optOutClient = newHttpClient();
    const redis = new Redis(optOutClient, { readYourWrites: false });

    const initialSync = optOutClient.upstashSyncToken;

    await redis.set("key", "value");

    const updatedSync = optOutClient.upstashSyncToken;

    expect(updatedSync).toEqual(initialSync);
  });

  test("should not update the sync state when public Redis interface is provided with opt-out", async () => {
    const redis = new PublicRedis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN,
      readYourWrites: false,
    });

    // @ts-expect-error - We need the sync token for this test, which resides on the client
    const initialSync = redis.client.upstashSyncToken;

    await redis.set("key", "value");

    // @ts-expect-error - We need the sync token for this test, which resides on the client
    const updatedSync = redis.client.upstashSyncToken;

    expect(updatedSync).toEqual(initialSync);
  });

  test("should update the sync state when public Redis interface is provided with default behaviour", async () => {
    const redis = new PublicRedis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN,
    });

    // @ts-expect-error - We need the sync token for this test, which resides on the client
    const initialSync = redis.client.upstashSyncToken;

    await redis.set("key", "value");

    // @ts-expect-error - We need the sync token for this test, which resides on the client
    const updatedSync = redis.client.upstashSyncToken;
    expect(updatedSync).not.toEqual(initialSync);
  });

  test("should updat read your writes sync token using set/get", async () => {
    const redis = new PublicRedis({
      url: process.env.UPSTASH_REDIS_REST_URL,
      token: process.env.UPSTASH_REDIS_REST_TOKEN,
    });

    // should change from "" to string
    expect(redis.readYourWritesSyncToken).toBe("");
    await redis.set("key", "value");
    expect(redis.readYourWritesSyncToken).not.toBe("");
    expect(typeof redis.readYourWritesSyncToken).toBe("string");

    // should change after set
    const syncToken = redis.readYourWritesSyncToken;
    await redis.set("key", "value");
    expect(syncToken).not.toBe(redis.readYourWritesSyncToken);

    // should be able to set
    const newSyncToken = "my-new-sync-token";
    redis.readYourWritesSyncToken = newSyncToken;
    expect(redis.readYourWritesSyncToken).toBe(newSyncToken);

    await redis.set("key", "value");
  });
});


================================================================================
# File: redis.test.ts
# Size: 7007 bytes
================================================================================

import { Redis } from "./redis";
import { keygen, newHttpClient, randomID } from "./test-utils";

import { afterEach, describe, expect, test } from "bun:test";
import { HttpClient } from "./http";
import type { ScanResultStandard, ScanResultWithType } from "./commands/scan";
const client = newHttpClient();

const { newKey, cleanup } = keygen();
afterEach(cleanup);

describe("when storing base64 data", () => {
  test(
    "general",
    async () => {
      const redis = new Redis(client);
      const key = newKey();
      const value = "VXBzdGFzaCBpcyByZWFsbHkgY29vbA";
      await redis.set(key, value);
      const res = await redis.get(key);
      expect(res).toEqual(value);
    },
    { timeout: 150_000 }
  );

  // decode("OK") => 8
  test("getting '8'", async () => {
    const redis = new Redis(client);
    const key = newKey();
    const value = 8;
    await redis.set(key, value);
    const res = await redis.get(key);
    expect(res).toEqual(value);
  });
  test("getting 'OK'", async () => {
    const redis = new Redis(client);
    const key = newKey();
    const value = "OK";
    await redis.set(key, value);
    const res = await redis.get(key);
    expect(res).toEqual(value);
  });
});

describe("mget", () => {
  const key = newKey();
  const key1 = newKey();
  const value = "foobar";
  const value1 = "foobar1";
  const redis = new Redis(client);
  const queries = [key, key1];

  test("mget with array", async () => {
    await redis.mset({ key: value, key1: value1 });
    const res = await redis.mget(queries);

    expect(res.length).toEqual(2);
  });

  test("mget with spreaded array", async () => {
    await redis.mset({ key: value, key1: value1 });
    const res = await redis.mget(...queries);

    expect(res.length).toEqual(2);
  });
});

describe("when destructuring the redis class", () => {
  test("correctly binds this", async () => {
    const { get, set } = new Redis(client);
    const key = newKey();
    const value = randomID();
    await set(key, value);
    const res = await get(key);
    expect(res).toEqual(value);
  });
});

describe("zadd", () => {
  test("adds the set", async () => {
    const key = newKey();
    const score = 1;
    const member = randomID();

    const res = await new Redis(client).zadd(key, { score, member });
    expect(res).toEqual(1);
  });
});

describe("zrange", () => {
  test("returns the range", async () => {
    const key = newKey();
    const score = 1;
    const member = randomID();
    const redis = new Redis(client);
    await redis.zadd(key, { score, member });
    const res = await redis.zrange(key, 0, 2);
    expect(res).toEqual([member]);
  });
});

describe("middleware", () => {
  let state = false;
  test("before", async () => {
    const r = new Redis(client);
    r.use(async (req, next) => {
      state = true;

      return await next(req);
    });

    await r.incr(newKey());

    expect(state).toEqual(true);
  });

  test("after", async () => {
    let state = false;
    const r = new Redis(client);
    r.use(async (req, next) => {
      const res = await next(req);
      state = true;
      return res;
    });

    await r.incr(newKey());

    expect(state).toEqual(true);
  });
});

describe("special data", () => {
  test("with %", async () => {
    const key = newKey();
    const value = "%%12";
    const redis = new Redis(client);
    await redis.set(key, value);
    const res = await redis.get<string>(key);

    expect(res).toEqual(value);
  });
  test("empty string", async () => {
    const key = newKey();
    const value = "";
    const redis = new Redis(client);
    await redis.set(key, value);
    const res = await redis.get<string>(key);

    expect(res).toEqual(value);
  });

  test("not found key", async () => {
    const redis = new Redis(client);
    const res = await redis.get<string>(newKey());

    expect(res).toEqual(null);
  });

  test("with encodeURIComponent", async () => {
    const key = newKey();
    const value = "😀";
    const redis = new Redis(client);
    await redis.set(key, encodeURIComponent(value));
    const res = await redis.get<string>(key);
    if (res) expect(decodeURIComponent(res)).toEqual(value);
  });

  test("without encodeURIComponent", async () => {
    const key = newKey();
    const value = "😀";
    const redis = new Redis(client);
    await redis.set(key, value);
    const res = await redis.get<string>(key);

    expect(res).toEqual(value);
  });
  test("emojis", async () => {
    const key = newKey();
    const value = "😀";
    const redis = new Redis(client);
    await redis.set(key, value);
    const res = await redis.get(key);

    expect(res).toEqual(value);
  });
});

describe("disable base64 encoding", () => {
  test("emojis", async () => {
    const key = newKey();
    const value = "😀";
    const url = process.env.UPSTASH_REDIS_REST_URL;
    if (!url) {
      throw new Error("Could not find url");
    }
    const token = process.env.UPSTASH_REDIS_REST_TOKEN;
    if (!token) {
      throw new Error("Could not find token");
    }

    const client = new HttpClient({
      baseUrl: url,
      headers: { authorization: `Bearer ${token}` },
      responseEncoding: false,
    });
    const redis = new Redis(client);
    await redis.set(key, value);
    const res = await redis.get(key);

    expect(res).toEqual(value);
  });

  test("random bytes", async () => {
    const key = newKey();
    const value = crypto.getRandomValues(new Uint8Array(2 ** 8)).toString();
    const url = process.env.UPSTASH_REDIS_REST_URL;
    if (!url) {
      throw new Error("Could not find url");
    }
    const token = process.env.UPSTASH_REDIS_REST_TOKEN;
    if (!token) {
      throw new Error("Could not find token");
    }

    const client = new HttpClient({
      baseUrl: url,
      headers: { authorization: `Bearer ${token}` },
      responseEncoding: false,
    });
    const redis = new Redis(client);
    redis.use(async (r, next) => {
      const res = await next(r);
      return res;
    });
    await redis.set(key, value);
    const res = await redis.get(key);

    expect(res).toEqual(value);
  });
});

describe("tests with latency logging", () => {
  test("test should return OK with latency logs", async () => {
    const redis = new Redis(client, { latencyLogging: true });
    const key = newKey();
    const value = "OK";
    await redis.set(key, value);
    const res = await redis.get(key);
    expect(res).toEqual(value);
  });
});

const assertIsType = <T>(_arg: () => T) => {};

describe("return type of scan withType", () => {
  test("should return cursor and keys with types", async () => {
    const redis = new Redis(client);

    assertIsType<Promise<ScanResultStandard>>(() => redis.scan("0"));

    assertIsType<Promise<ScanResultStandard>>(() => redis.scan("0", {}));

    assertIsType<Promise<ScanResultStandard>>(() => redis.scan("0", { withType: false }));

    assertIsType<Promise<ScanResultWithType>>(() => redis.scan("0", { withType: true }));
  });
});


================================================================================
# File: redis.ts
# Size: 45185 bytes
================================================================================

import { createAutoPipelineProxy } from "../pkg/auto-pipeline";
import type {
  CommandOptions,
  ScoreMember,
  SetCommandOptions,
  ZAddCommandOptions,
  ZRangeCommandOptions,
  ScanCommandOptions,
  ScanResultStandard,
  ScanResultWithType,
} from "./commands/mod";
import {
  AppendCommand,
  BitCountCommand,
  BitFieldCommand,
  BitOpCommand,
  BitPosCommand,
  CopyCommand,
  DBSizeCommand,
  DecrByCommand,
  DecrCommand,
  DelCommand,
  EchoCommand,
  EvalROCommand,
  EvalCommand,
  EvalshaROCommand,
  EvalshaCommand,
  ExecCommand,
  ExistsCommand,
  ExpireAtCommand,
  ExpireCommand,
  FlushAllCommand,
  FlushDBCommand,
  GeoAddCommand,
  GeoDistCommand,
  GeoHashCommand,
  GeoPosCommand,
  GeoSearchCommand,
  GeoSearchStoreCommand,
  GetBitCommand,
  GetCommand,
  GetDelCommand,
  GetExCommand,
  GetRangeCommand,
  GetSetCommand,
  HDelCommand,
  HExistsCommand,
  HExpireCommand,
  HExpireAtCommand,
  HExpireTimeCommand,
  HTtlCommand,
  HPExpireCommand,
  HPExpireAtCommand,
  HPExpireTimeCommand,
  HPTtlCommand,
  HPersistCommand,
  HGetAllCommand,
  HGetCommand,
  HIncrByCommand,
  HIncrByFloatCommand,
  HKeysCommand,
  HLenCommand,
  HMGetCommand,
  HMSetCommand,
  HRandFieldCommand,
  HScanCommand,
  HSetCommand,
  HSetNXCommand,
  HStrLenCommand,
  HValsCommand,
  IncrByCommand,
  IncrByFloatCommand,
  IncrCommand,
  JsonArrAppendCommand,
  JsonArrIndexCommand,
  JsonArrInsertCommand,
  JsonArrLenCommand,
  JsonArrPopCommand,
  JsonArrTrimCommand,
  JsonClearCommand,
  JsonDelCommand,
  JsonForgetCommand,
  JsonGetCommand,
  JsonMergeCommand,
  JsonMGetCommand,
  JsonMSetCommand,
  JsonNumIncrByCommand,
  JsonNumMultByCommand,
  JsonObjKeysCommand,
  JsonObjLenCommand,
  JsonRespCommand,
  JsonSetCommand,
  JsonStrAppendCommand,
  JsonStrLenCommand,
  JsonToggleCommand,
  JsonTypeCommand,
  KeysCommand,
  LIndexCommand,
  LInsertCommand,
  LLenCommand,
  LMoveCommand,
  LPopCommand,
  LPosCommand,
  LPushCommand,
  LPushXCommand,
  LRangeCommand,
  LRemCommand,
  LSetCommand,
  LTrimCommand,
  LmPopCommand,
  MGetCommand,
  MSetCommand,
  MSetNXCommand,
  PExpireAtCommand,
  PExpireCommand,
  PSetEXCommand,
  PTtlCommand,
  PersistCommand,
  PfAddCommand,
  PfCountCommand,
  PfMergeCommand,
  PingCommand,
  PublishCommand,
  RPopCommand,
  RPushCommand,
  RPushXCommand,
  RandomKeyCommand,
  RenameCommand,
  RenameNXCommand,
  SAddCommand,
  SCardCommand,
  SDiffCommand,
  SDiffStoreCommand,
  SInterCommand,
  SInterStoreCommand,
  SIsMemberCommand,
  SMIsMemberCommand,
  SMembersCommand,
  SMoveCommand,
  SPopCommand,
  SRandMemberCommand,
  SRemCommand,
  SScanCommand,
  SUnionCommand,
  SUnionStoreCommand,
  ScanCommand,
  ScriptExistsCommand,
  ScriptFlushCommand,
  ScriptLoadCommand,
  SetBitCommand,
  SetCommand,
  SetExCommand,
  SetNxCommand,
  SetRangeCommand,
  StrLenCommand,
  TimeCommand,
  TouchCommand,
  TtlCommand,
  TypeCommand,
  UnlinkCommand,
  XAckCommand,
  XAddCommand,
  XAutoClaim,
  XClaimCommand,
  XDelCommand,
  XGroupCommand,
  XInfoCommand,
  XLenCommand,
  XPendingCommand,
  XRangeCommand,
  XReadCommand,
  XReadGroupCommand,
  XRevRangeCommand,
  XTrimCommand,
  ZAddCommand,
  ZCardCommand,
  ZCountCommand,
  ZIncrByCommand,
  ZInterStoreCommand,
  ZLexCountCommand,
  ZPopMaxCommand,
  ZPopMinCommand,
  ZRangeCommand,
  ZRankCommand,
  ZRemCommand,
  ZRemRangeByLexCommand,
  ZRemRangeByRankCommand,
  ZRemRangeByScoreCommand,
  ZRevRankCommand,
  ZScanCommand,
  ZScoreCommand,
  ZUnionCommand,
  ZUnionStoreCommand,
} from "./commands/mod";
import { Subscriber } from "./commands/subscribe";
import { ZDiffStoreCommand } from "./commands/zdiffstore";
import { ZMScoreCommand } from "./commands/zmscore";
import type { Requester, UpstashRequest, UpstashResponse } from "./http";
import { Pipeline } from "./pipeline";
import { Script } from "./script";
import { ScriptRO } from "./scriptRo";
import type { CommandArgs, RedisOptions, Telemetry } from "./types";

// See https://github.com/upstash/upstash-redis/issues/342
// why we need this export
export type { RedisOptions } from "./types";

/**
 * Serverless redis client for upstash.
 */
export class Redis {
  protected client: Requester;
  protected opts?: CommandOptions<any, any>;
  protected enableTelemetry: boolean;
  protected enableAutoPipelining: boolean;

  /**
   * Create a new redis client
   *
   * @example
   * ```typescript
   * const redis = new Redis({
   *  url: "<UPSTASH_REDIS_REST_URL>",
   *  token: "<UPSTASH_REDIS_REST_TOKEN>",
   * });
   * ```
   */
  constructor(client: Requester, opts?: RedisOptions) {
    this.client = client;
    this.opts = opts;
    this.enableTelemetry = opts?.enableTelemetry ?? true;

    if (opts?.readYourWrites === false) {
      this.client.readYourWrites = false;
    }
    this.enableAutoPipelining = opts?.enableAutoPipelining ?? true;
  }

  get readYourWritesSyncToken(): string | undefined {
    return this.client.upstashSyncToken;
  }

  set readYourWritesSyncToken(session: string | undefined) {
    this.client.upstashSyncToken = session;
  }

  get json() {
    return {
      /**
       * @see https://redis.io/commands/json.arrappend
       */
      arrappend: (...args: CommandArgs<typeof JsonArrAppendCommand>) =>
        new JsonArrAppendCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.arrindex
       */
      arrindex: (...args: CommandArgs<typeof JsonArrIndexCommand>) =>
        new JsonArrIndexCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.arrinsert
       */
      arrinsert: (...args: CommandArgs<typeof JsonArrInsertCommand>) =>
        new JsonArrInsertCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.arrlen
       */
      arrlen: (...args: CommandArgs<typeof JsonArrLenCommand>) =>
        new JsonArrLenCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.arrpop
       */
      arrpop: (...args: CommandArgs<typeof JsonArrPopCommand>) =>
        new JsonArrPopCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.arrtrim
       */
      arrtrim: (...args: CommandArgs<typeof JsonArrTrimCommand>) =>
        new JsonArrTrimCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.clear
       */
      clear: (...args: CommandArgs<typeof JsonClearCommand>) =>
        new JsonClearCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.del
       */
      del: (...args: CommandArgs<typeof JsonDelCommand>) =>
        new JsonDelCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.forget
       */
      forget: (...args: CommandArgs<typeof JsonForgetCommand>) =>
        new JsonForgetCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.get
       */
      get: <TData>(...args: CommandArgs<typeof JsonGetCommand>) =>
        new JsonGetCommand<TData>(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.merge
       */
      merge: (...args: CommandArgs<typeof JsonMergeCommand>) =>
        new JsonMergeCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.mget
       */
      mget: <TData>(...args: CommandArgs<typeof JsonMGetCommand>) =>
        new JsonMGetCommand<TData>(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.mset
       */
      mset: (...args: CommandArgs<typeof JsonMSetCommand>) =>
        new JsonMSetCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.numincrby
       */
      numincrby: (...args: CommandArgs<typeof JsonNumIncrByCommand>) =>
        new JsonNumIncrByCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.nummultby
       */
      nummultby: (...args: CommandArgs<typeof JsonNumMultByCommand>) =>
        new JsonNumMultByCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.objkeys
       */
      objkeys: (...args: CommandArgs<typeof JsonObjKeysCommand>) =>
        new JsonObjKeysCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.objlen
       */
      objlen: (...args: CommandArgs<typeof JsonObjLenCommand>) =>
        new JsonObjLenCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.resp
       */
      resp: (...args: CommandArgs<typeof JsonRespCommand>) =>
        new JsonRespCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.set
       */
      set: (...args: CommandArgs<typeof JsonSetCommand>) =>
        new JsonSetCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.strappend
       */
      strappend: (...args: CommandArgs<typeof JsonStrAppendCommand>) =>
        new JsonStrAppendCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.strlen
       */
      strlen: (...args: CommandArgs<typeof JsonStrLenCommand>) =>
        new JsonStrLenCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.toggle
       */
      toggle: (...args: CommandArgs<typeof JsonToggleCommand>) =>
        new JsonToggleCommand(args, this.opts).exec(this.client),

      /**
       * @see https://redis.io/commands/json.type
       */
      type: (...args: CommandArgs<typeof JsonTypeCommand>) =>
        new JsonTypeCommand(args, this.opts).exec(this.client),
    };
  }
  /**
   * Wrap a new middleware around the HTTP client.
   */
  use = <TResult = unknown>(
    middleware: (
      r: UpstashRequest,
      next: <TResult = unknown>(req: UpstashRequest) => Promise<UpstashResponse<TResult>>
    ) => Promise<UpstashResponse<TResult>>
  ) => {
    const makeRequest = this.client.request.bind(this.client);
    this.client.request = (req: UpstashRequest) => middleware(req, makeRequest) as any;
  };

  /**
   * Technically this is not private, we can hide it from intellisense by doing this
   */
  protected addTelemetry = (telemetry: Telemetry) => {
    if (!this.enableTelemetry) {
      return;
    }
    try {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore - The `Requester` interface does not know about this method but it will be there
      // as long as the user uses the standard HttpClient
      this.client.mergeTelemetry(telemetry);
    } catch {
      // ignore
    }
  };

  /**
   * Creates a new script.
   *
   * Scripts offer the ability to optimistically try to execute a script without having to send the
   * entire script to the server. If the script is loaded on the server, it tries again by sending
   * the entire script. Afterwards, the script is cached on the server.
   *
   * @param script - The script to create
   * @param opts - Optional options to pass to the script `{ readonly?: boolean }`
   * @returns A new script
   *
   * @example
   * ```ts
   * const redis = new Redis({...})
   *
   * const script = redis.createScript<string>("return ARGV[1];")
   * const arg1 = await script.eval([], ["Hello World"])
   * expect(arg1, "Hello World")
   * ```
   * @example
   * ```ts
   * const redis = new Redis({...})
   *
   * const script = redis.createScript<string>("return ARGV[1];", { readonly: true })
   * const arg1 = await script.evalRo([], ["Hello World"])
   * expect(arg1, "Hello World")
   * ```
   */

  createScript<TResult = unknown, TReadonly extends boolean = false>(
    script: string,
    opts?: { readonly?: TReadonly }
  ): TReadonly extends true ? ScriptRO<TResult> : Script<TResult> {
    return opts?.readonly ? (new ScriptRO(this, script) as any) : (new Script(this, script) as any);
  }

  /**
   * Create a new pipeline that allows you to send requests in bulk.
   *
   * @see {@link Pipeline}
   */
  pipeline = () =>
    new Pipeline({
      client: this.client,
      commandOptions: this.opts,
      multiExec: false,
    });

  protected autoPipeline = () => {
    return createAutoPipelineProxy(this);
  };

  /**
   * Create a new transaction to allow executing multiple steps atomically.
   *
   * All the commands in a transaction are serialized and executed sequentially. A request sent by
   * another client will never be served in the middle of the execution of a Redis Transaction. This
   * guarantees that the commands are executed as a single isolated operation.
   *
   * @see {@link Pipeline}
   */
  multi = () =>
    new Pipeline({
      client: this.client,
      commandOptions: this.opts,
      multiExec: true,
    });

  /**
   * Returns an instance that can be used to execute `BITFIELD` commands on one key.
   *
   * @example
   * ```typescript
   * redis.set("mykey", 0);
   * const result = await redis.bitfield("mykey")
   *   .set("u4", 0, 16)
   *   .incr("u4", "#1", 1)
   *   .exec();
   * console.log(result); // [0, 1]
   * ```
   *
   * @see https://redis.io/commands/bitfield
   */
  bitfield = (...args: CommandArgs<typeof BitFieldCommand>) =>
    new BitFieldCommand(args, this.client, this.opts);

  /**
   * @see https://redis.io/commands/append
   */
  append = (...args: CommandArgs<typeof AppendCommand>) =>
    new AppendCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/bitcount
   */
  bitcount = (...args: CommandArgs<typeof BitCountCommand>) =>
    new BitCountCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/bitop
   */
  bitop: {
    (
      op: "and" | "or" | "xor",
      destinationKey: string,
      sourceKey: string,
      ...sourceKeys: string[]
    ): Promise<number>;
    (op: "not", destinationKey: string, sourceKey: string): Promise<number>;
  } = (
    op: "and" | "or" | "xor" | "not",
    destinationKey: string,
    sourceKey: string,
    ...sourceKeys: string[]
  ) =>
    new BitOpCommand([op as any, destinationKey, sourceKey, ...sourceKeys], this.opts).exec(
      this.client
    );

  /**
   * @see https://redis.io/commands/bitpos
   */
  bitpos = (...args: CommandArgs<typeof BitPosCommand>) =>
    new BitPosCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/copy
   */
  copy = (...args: CommandArgs<typeof CopyCommand>) =>
    new CopyCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/dbsize
   */
  dbsize = () => new DBSizeCommand(this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/decr
   */
  decr = (...args: CommandArgs<typeof DecrCommand>) =>
    new DecrCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/decrby
   */
  decrby = (...args: CommandArgs<typeof DecrByCommand>) =>
    new DecrByCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/del
   */
  del = (...args: CommandArgs<typeof DelCommand>) =>
    new DelCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/echo
   */
  echo = (...args: CommandArgs<typeof EchoCommand>) =>
    new EchoCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/eval_ro
   */
  evalRo = <TArgs extends unknown[], TData = unknown>(
    ...args: [script: string, keys: string[], args: TArgs]
  ) => new EvalROCommand<TArgs, TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/eval
   */
  eval = <TArgs extends unknown[], TData = unknown>(
    ...args: [script: string, keys: string[], args: TArgs]
  ) => new EvalCommand<TArgs, TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/evalsha_ro
   */
  evalshaRo = <TArgs extends unknown[], TData = unknown>(
    ...args: [sha1: string, keys: string[], args: TArgs]
  ) => new EvalshaROCommand<TArgs, TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/evalsha
   */
  evalsha = <TArgs extends unknown[], TData = unknown>(
    ...args: [sha1: string, keys: string[], args: TArgs]
  ) => new EvalshaCommand<TArgs, TData>(args, this.opts).exec(this.client);

  /**
   * Generic method to execute any Redis command.
   */
  exec = <TResult>(args: [command: string, ...args: (string | number | boolean)[]]) =>
    new ExecCommand<TResult>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/exists
   */
  exists = (...args: CommandArgs<typeof ExistsCommand>) =>
    new ExistsCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/expire
   */
  expire = (...args: CommandArgs<typeof ExpireCommand>) =>
    new ExpireCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/expireat
   */
  expireat = (...args: CommandArgs<typeof ExpireAtCommand>) =>
    new ExpireAtCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/flushall
   */
  flushall = (args?: CommandArgs<typeof FlushAllCommand>) =>
    new FlushAllCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/flushdb
   */
  flushdb = (...args: CommandArgs<typeof FlushDBCommand>) =>
    new FlushDBCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/geoadd
   */
  geoadd = <TData>(...args: CommandArgs<typeof GeoAddCommand<TData>>) =>
    new GeoAddCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/geopos
   */
  geopos = <TData>(...args: CommandArgs<typeof GeoPosCommand<TData>>) =>
    new GeoPosCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/geodist
   */
  geodist = <TData>(...args: CommandArgs<typeof GeoDistCommand<TData>>) =>
    new GeoDistCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/geohash
   */
  geohash = <TData>(...args: CommandArgs<typeof GeoHashCommand<TData>>) =>
    new GeoHashCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/geosearch
   */
  geosearch = <TData>(...args: CommandArgs<typeof GeoSearchCommand<TData>>) =>
    new GeoSearchCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/geosearchstore
   */
  geosearchstore = <TData>(...args: CommandArgs<typeof GeoSearchStoreCommand<TData>>) =>
    new GeoSearchStoreCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/get
   */
  get = <TData>(...args: CommandArgs<typeof GetCommand>) =>
    new GetCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/getbit
   */
  getbit = (...args: CommandArgs<typeof GetBitCommand>) =>
    new GetBitCommand(args, this.opts).exec(this.client);
  /**
   * @see https://redis.io/commands/getdel
   */
  getdel = <TData>(...args: CommandArgs<typeof GetDelCommand>) =>
    new GetDelCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/getex
   */
  getex = <TData>(...args: CommandArgs<typeof GetExCommand>) =>
    new GetExCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/getrange
   */
  getrange = (...args: CommandArgs<typeof GetRangeCommand>) =>
    new GetRangeCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/getset
   */
  getset = <TData>(key: string, value: TData) =>
    new GetSetCommand<TData>([key, value], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hdel
   */
  hdel = (...args: CommandArgs<typeof HDelCommand>) =>
    new HDelCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hexists
   */
  hexists = (...args: CommandArgs<typeof HExistsCommand>) =>
    new HExistsCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hexpire
   */
  hexpire = (...args: CommandArgs<typeof HExpireCommand>) =>
    new HExpireCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hexpireat
   */
  hexpireat = (...args: CommandArgs<typeof HExpireAtCommand>) =>
    new HExpireAtCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hexpiretime
   */
  hexpiretime = (...args: CommandArgs<typeof HExpireTimeCommand>) =>
    new HExpireTimeCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/httl
   */
  httl = (...args: CommandArgs<typeof HTtlCommand>) =>
    new HTtlCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hpexpire
   */
  hpexpire = (...args: CommandArgs<typeof HPExpireCommand>) =>
    new HPExpireCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hpexpireat
   */
  hpexpireat = (...args: CommandArgs<typeof HPExpireAtCommand>) =>
    new HPExpireAtCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hpexpiretime
   */
  hpexpiretime = (...args: CommandArgs<typeof HPExpireTimeCommand>) =>
    new HPExpireTimeCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hpttl
   */
  hpttl = (...args: CommandArgs<typeof HPTtlCommand>) =>
    new HPTtlCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hpersist
   */
  hpersist = (...args: CommandArgs<typeof HPersistCommand>) =>
    new HPersistCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hget
   */
  hget = <TData>(...args: CommandArgs<typeof HGetCommand>) =>
    new HGetCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hgetall
   */
  hgetall = <TData extends Record<string, unknown>>(...args: CommandArgs<typeof HGetAllCommand>) =>
    new HGetAllCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hincrby
   */
  hincrby = (...args: CommandArgs<typeof HIncrByCommand>) =>
    new HIncrByCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hincrbyfloat
   */
  hincrbyfloat = (...args: CommandArgs<typeof HIncrByFloatCommand>) =>
    new HIncrByFloatCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hkeys
   */
  hkeys = (...args: CommandArgs<typeof HKeysCommand>) =>
    new HKeysCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hlen
   */
  hlen = (...args: CommandArgs<typeof HLenCommand>) =>
    new HLenCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hmget
   */
  hmget = <TData extends Record<string, unknown>>(...args: CommandArgs<typeof HMGetCommand>) =>
    new HMGetCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hmset
   */
  hmset = <TData>(key: string, kv: Record<string, TData>) =>
    new HMSetCommand([key, kv], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hrandfield
   */
  hrandfield: {
    (key: string): Promise<string | null>;
    (key: string, count: number): Promise<string[]>;
    <TData extends Record<string, unknown>>(
      key: string,
      count: number,
      withValues: boolean
    ): Promise<Partial<TData>>;
  } = <TData extends string | string[] | Record<string, unknown>>(
    key: string,
    count?: number,
    withValues?: boolean
  ) => new HRandFieldCommand<TData>([key, count, withValues] as any, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hscan
   */
  hscan = (...args: CommandArgs<typeof HScanCommand>) =>
    new HScanCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hset
   */
  hset = <TData>(key: string, kv: Record<string, TData>) =>
    new HSetCommand<TData>([key, kv], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hsetnx
   */
  hsetnx = <TData>(key: string, field: string, value: TData) =>
    new HSetNXCommand<TData>([key, field, value], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hstrlen
   */
  hstrlen = (...args: CommandArgs<typeof HStrLenCommand>) =>
    new HStrLenCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/hvals
   */
  hvals = (...args: CommandArgs<typeof HValsCommand>) =>
    new HValsCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/incr
   */
  incr = (...args: CommandArgs<typeof IncrCommand>) =>
    new IncrCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/incrby
   */
  incrby = (...args: CommandArgs<typeof IncrByCommand>) =>
    new IncrByCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/incrbyfloat
   */
  incrbyfloat = (...args: CommandArgs<typeof IncrByFloatCommand>) =>
    new IncrByFloatCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/keys
   */
  keys = (...args: CommandArgs<typeof KeysCommand>) =>
    new KeysCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/lindex
   */
  lindex = (...args: CommandArgs<typeof LIndexCommand>) =>
    new LIndexCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/linsert
   */
  linsert = <TData>(key: string, direction: "before" | "after", pivot: TData, value: TData) =>
    new LInsertCommand<TData>([key, direction, pivot, value], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/llen
   */
  llen = (...args: CommandArgs<typeof LLenCommand>) =>
    new LLenCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/lmove
   */
  lmove = <TData = string>(...args: CommandArgs<typeof LMoveCommand>) =>
    new LMoveCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/lpop
   */
  lpop = <TData>(...args: CommandArgs<typeof LPopCommand>) =>
    new LPopCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/lmpop
   */
  lmpop = <TData>(...args: CommandArgs<typeof LmPopCommand>) =>
    new LmPopCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/lpos
   */
  lpos = <TData = number>(...args: CommandArgs<typeof LPosCommand>) =>
    new LPosCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/lpush
   */
  lpush = <TData>(key: string, ...elements: TData[]) =>
    new LPushCommand<TData>([key, ...elements], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/lpushx
   */
  lpushx = <TData>(key: string, ...elements: TData[]) =>
    new LPushXCommand<TData>([key, ...elements], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/lrange
   */
  lrange = <TResult = string>(...args: CommandArgs<typeof LRangeCommand>) =>
    new LRangeCommand<TResult>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/lrem
   */
  lrem = <TData>(key: string, count: number, value: TData) =>
    new LRemCommand([key, count, value], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/lset
   */
  lset = <TData>(key: string, index: number, value: TData) =>
    new LSetCommand([key, index, value], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/ltrim
   */
  ltrim = (...args: CommandArgs<typeof LTrimCommand>) =>
    new LTrimCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/mget
   */
  mget = <TData extends unknown[]>(...args: CommandArgs<typeof MGetCommand>) =>
    new MGetCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/mset
   */
  mset = <TData>(kv: Record<string, TData>) =>
    new MSetCommand<TData>([kv], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/msetnx
   */
  msetnx = <TData>(kv: Record<string, TData>) =>
    new MSetNXCommand<TData>([kv], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/persist
   */
  persist = (...args: CommandArgs<typeof PersistCommand>) =>
    new PersistCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/pexpire
   */
  pexpire = (...args: CommandArgs<typeof PExpireCommand>) =>
    new PExpireCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/pexpireat
   */
  pexpireat = (...args: CommandArgs<typeof PExpireAtCommand>) =>
    new PExpireAtCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/pfadd
   */
  pfadd = (...args: CommandArgs<typeof PfAddCommand>) =>
    new PfAddCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/pfcount
   */
  pfcount = (...args: CommandArgs<typeof PfCountCommand>) =>
    new PfCountCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/pfmerge
   */
  pfmerge = (...args: CommandArgs<typeof PfMergeCommand>) =>
    new PfMergeCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/ping
   */
  ping = (args?: CommandArgs<typeof PingCommand>) =>
    new PingCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/psetex
   */
  psetex = <TData>(key: string, ttl: number, value: TData) =>
    new PSetEXCommand<TData>([key, ttl, value], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/psubscribe
   */
  psubscribe = <TMessage>(patterns: string | string[]): Subscriber<TMessage> => {
    const patternArray = Array.isArray(patterns) ? patterns : [patterns];
    return new Subscriber<TMessage>(this.client, patternArray, true);
  };

  /**
   * @see https://redis.io/commands/pttl
   */
  pttl = (...args: CommandArgs<typeof PTtlCommand>) =>
    new PTtlCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/publish
   */
  publish = (...args: CommandArgs<typeof PublishCommand>) =>
    new PublishCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/randomkey
   */
  randomkey = () => new RandomKeyCommand().exec(this.client);

  /**
   * @see https://redis.io/commands/rename
   */
  rename = (...args: CommandArgs<typeof RenameCommand>) =>
    new RenameCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/renamenx
   */
  renamenx = (...args: CommandArgs<typeof RenameNXCommand>) =>
    new RenameNXCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/rpop
   */
  rpop = <TData = string>(...args: CommandArgs<typeof RPopCommand>) =>
    new RPopCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/rpush
   */
  rpush = <TData>(key: string, ...elements: TData[]) =>
    new RPushCommand([key, ...elements], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/rpushx
   */
  rpushx = <TData>(key: string, ...elements: TData[]) =>
    new RPushXCommand([key, ...elements], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/sadd
   */
  sadd = <TData>(key: string, member: TData, ...members: TData[]) =>
    new SAddCommand<TData>([key, member, ...members], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/scan
   */
  scan(cursor: string | number): Promise<ScanResultStandard>;
  scan<TOptions extends ScanCommandOptions>(
    cursor: string | number,
    opts: TOptions
  ): Promise<TOptions extends { withType: true } ? ScanResultWithType : ScanResultStandard>;
  scan<TOptions extends ScanCommandOptions>(
    cursor: string | number,
    opts?: TOptions
  ): Promise<TOptions extends { withType: true } ? ScanResultWithType : ScanResultStandard> {
    return new ScanCommand([cursor, opts], this.opts).exec(this.client);
  }

  /**
   * @see https://redis.io/commands/scard
   */
  scard = (...args: CommandArgs<typeof SCardCommand>) =>
    new SCardCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/script-exists
   */
  scriptExists = (...args: CommandArgs<typeof ScriptExistsCommand>) =>
    new ScriptExistsCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/script-flush
   */
  scriptFlush = (...args: CommandArgs<typeof ScriptFlushCommand>) =>
    new ScriptFlushCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/script-load
   */
  scriptLoad = (...args: CommandArgs<typeof ScriptLoadCommand>) =>
    new ScriptLoadCommand(args, this.opts).exec(this.client);
  /**
   * @see https://redis.io/commands/sdiff
   */
  sdiff = (...args: CommandArgs<typeof SDiffCommand>) =>
    new SDiffCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/sdiffstore
   */
  sdiffstore = (...args: CommandArgs<typeof SDiffStoreCommand>) =>
    new SDiffStoreCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/set
   */
  set = <TData>(key: string, value: TData, opts?: SetCommandOptions) =>
    new SetCommand<TData>([key, value, opts], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/setbit
   */
  setbit = (...args: CommandArgs<typeof SetBitCommand>) =>
    new SetBitCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/setex
   */
  setex = <TData>(key: string, ttl: number, value: TData) =>
    new SetExCommand<TData>([key, ttl, value], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/setnx
   */
  setnx = <TData>(key: string, value: TData) =>
    new SetNxCommand<TData>([key, value], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/setrange
   */
  setrange = (...args: CommandArgs<typeof SetRangeCommand>) =>
    new SetRangeCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/sinter
   */
  sinter = (...args: CommandArgs<typeof SInterCommand>) =>
    new SInterCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/sinterstore
   */
  sinterstore = (...args: CommandArgs<typeof SInterStoreCommand>) =>
    new SInterStoreCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/sismember
   */
  sismember = <TData>(key: string, member: TData) =>
    new SIsMemberCommand<TData>([key, member], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/smismember
   */
  smismember = <TMembers extends unknown[]>(key: string, members: TMembers) =>
    new SMIsMemberCommand<TMembers>([key, members], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/smembers
   */
  smembers = <TData extends unknown[] = string[]>(...args: CommandArgs<typeof SMembersCommand>) =>
    new SMembersCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/smove
   */
  smove = <TData>(source: string, destination: string, member: TData) =>
    new SMoveCommand<TData>([source, destination, member], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/spop
   */
  spop = <TData>(...args: CommandArgs<typeof SPopCommand>) =>
    new SPopCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/srandmember
   */
  srandmember = <TData>(...args: CommandArgs<typeof SRandMemberCommand>) =>
    new SRandMemberCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/srem
   */
  srem = <TData>(key: string, ...members: TData[]) =>
    new SRemCommand<TData>([key, ...members], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/sscan
   */
  sscan = (...args: CommandArgs<typeof SScanCommand>) =>
    new SScanCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/strlen
   */
  strlen = (...args: CommandArgs<typeof StrLenCommand>) =>
    new StrLenCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/subscribe
   */
  subscribe = <TMessage>(channels: string | string[]): Subscriber<TMessage> => {
    const channelArray = Array.isArray(channels) ? channels : [channels];
    return new Subscriber<TMessage>(this.client, channelArray);
  };
  /**
   * @see https://redis.io/commands/sunion
   */
  sunion = (...args: CommandArgs<typeof SUnionCommand>) =>
    new SUnionCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/sunionstore
   */
  sunionstore = (...args: CommandArgs<typeof SUnionStoreCommand>) =>
    new SUnionStoreCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/time
   */
  time = () => new TimeCommand().exec(this.client);

  /**
   * @see https://redis.io/commands/touch
   */
  touch = (...args: CommandArgs<typeof TouchCommand>) =>
    new TouchCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/ttl
   */
  ttl = (...args: CommandArgs<typeof TtlCommand>) =>
    new TtlCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/type
   */
  type = (...args: CommandArgs<typeof TypeCommand>) =>
    new TypeCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/unlink
   */
  unlink = (...args: CommandArgs<typeof UnlinkCommand>) =>
    new UnlinkCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xadd
   */
  xadd = (...args: CommandArgs<typeof XAddCommand>) =>
    new XAddCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xack
   */
  xack = (...args: CommandArgs<typeof XAckCommand>) =>
    new XAckCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xdel
   */
  xdel = (...args: CommandArgs<typeof XDelCommand>) =>
    new XDelCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xgroup
   */
  xgroup = (...args: CommandArgs<typeof XGroupCommand>) =>
    new XGroupCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xread
   */
  xread = (...args: CommandArgs<typeof XReadCommand>) =>
    new XReadCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xreadgroup
   */
  xreadgroup = (...args: CommandArgs<typeof XReadGroupCommand>) =>
    new XReadGroupCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xinfo
   */
  xinfo = (...args: CommandArgs<typeof XInfoCommand>) =>
    new XInfoCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xlen
   */
  xlen = (...args: CommandArgs<typeof XLenCommand>) =>
    new XLenCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xpending
   */
  xpending = (...args: CommandArgs<typeof XPendingCommand>) =>
    new XPendingCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xclaim
   */
  xclaim = (...args: CommandArgs<typeof XClaimCommand>) =>
    new XClaimCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xautoclaim
   */
  xautoclaim = (...args: CommandArgs<typeof XAutoClaim>) =>
    new XAutoClaim(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xtrim
   */
  xtrim = (...args: CommandArgs<typeof XTrimCommand>) =>
    new XTrimCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xrange
   */
  xrange = (...args: CommandArgs<typeof XRangeCommand>) =>
    new XRangeCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/xrevrange
   */
  xrevrange = (...args: CommandArgs<typeof XRevRangeCommand>) =>
    new XRevRangeCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zadd
   */
  zadd = <TData>(
    ...args:
      | [key: string, scoreMember: ScoreMember<TData>, ...scoreMemberPairs: ScoreMember<TData>[]]
      | [
          key: string,
          opts: ZAddCommandOptions,
          ...scoreMemberPairs: [ScoreMember<TData>, ...ScoreMember<TData>[]],
        ]
  ) => {
    if ("score" in args[1]) {
      return new ZAddCommand<TData>([args[0], args[1], ...(args.slice(2) as any)], this.opts).exec(
        this.client
      );
    }

    return new ZAddCommand<TData>(
      [args[0], args[1] as any, ...(args.slice(2) as any)],
      this.opts
    ).exec(this.client);
  };
  /**
   * @see https://redis.io/commands/zcard
   */
  zcard = (...args: CommandArgs<typeof ZCardCommand>) =>
    new ZCardCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zcount
   */
  zcount = (...args: CommandArgs<typeof ZCountCommand>) =>
    new ZCountCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zdiffstore
   */
  zdiffstore = (...args: CommandArgs<typeof ZDiffStoreCommand>) =>
    new ZDiffStoreCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zincrby
   */
  zincrby = <TData>(key: string, increment: number, member: TData) =>
    new ZIncrByCommand<TData>([key, increment, member], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zinterstore
   */
  zinterstore = (...args: CommandArgs<typeof ZInterStoreCommand>) =>
    new ZInterStoreCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zlexcount
   */
  zlexcount = (...args: CommandArgs<typeof ZLexCountCommand>) =>
    new ZLexCountCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zmscore
   */
  zmscore = (...args: CommandArgs<typeof ZMScoreCommand>) =>
    new ZMScoreCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zpopmax
   */
  zpopmax = <TData>(...args: CommandArgs<typeof ZPopMaxCommand>) =>
    new ZPopMaxCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zpopmin
   */
  zpopmin = <TData>(...args: CommandArgs<typeof ZPopMinCommand>) =>
    new ZPopMinCommand<TData>(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zrange
   */
  zrange = <TData extends unknown[]>(
    ...args:
      | [key: string, min: number, max: number, opts?: ZRangeCommandOptions]
      | [
          key: string,
          min: `(${string}` | `[${string}` | "-" | "+",
          max: `(${string}` | `[${string}` | "-" | "+",
          opts: { byLex: true } & ZRangeCommandOptions,
        ]
      | [
          key: string,
          min: number | `(${number}` | "-inf" | "+inf",
          max: number | `(${number}` | "-inf" | "+inf",
          opts: { byScore: true } & ZRangeCommandOptions,
        ]
  ) => new ZRangeCommand<TData>(args as any, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zrank
   */
  zrank = <TData>(key: string, member: TData) =>
    new ZRankCommand<TData>([key, member], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zrem
   */
  zrem = <TData>(key: string, ...members: TData[]) =>
    new ZRemCommand<TData>([key, ...members], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zremrangebylex
   */
  zremrangebylex = (...args: CommandArgs<typeof ZRemRangeByLexCommand>) =>
    new ZRemRangeByLexCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zremrangebyrank
   */
  zremrangebyrank = (...args: CommandArgs<typeof ZRemRangeByRankCommand>) =>
    new ZRemRangeByRankCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zremrangebyscore
   */
  zremrangebyscore = (...args: CommandArgs<typeof ZRemRangeByScoreCommand>) =>
    new ZRemRangeByScoreCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zrevrank
   */
  zrevrank = <TData>(key: string, member: TData) =>
    new ZRevRankCommand<TData>([key, member], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zscan
   */
  zscan = (...args: CommandArgs<typeof ZScanCommand>) =>
    new ZScanCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zscore
   */
  zscore = <TData>(key: string, member: TData) =>
    new ZScoreCommand<TData>([key, member], this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zunion
   */
  zunion = (...args: CommandArgs<typeof ZUnionCommand>) =>
    new ZUnionCommand(args, this.opts).exec(this.client);

  /**
   * @see https://redis.io/commands/zunionstore
   */
  zunionstore = (...args: CommandArgs<typeof ZUnionStoreCommand>) =>
    new ZUnionStoreCommand(args, this.opts).exec(this.client);
}


================================================================================
# File: script.test.ts
# Size: 1804 bytes
================================================================================

import { afterEach, describe, expect, test } from "bun:test";
import { Redis } from "./redis";
import { keygen, newHttpClient, randomID } from "./test-utils";
const client = newHttpClient();

const { cleanup } = keygen();
afterEach(cleanup);

describe("create a new script", () => {
  test(
    "creates a new script",
    async () => {
      const redis = new Redis(client);
      const script = redis.createScript("return ARGV[1];");

      const res = await script.eval([], ["Hello World"]);
      expect(res).toEqual("Hello World");
    },
    { timeout: 15_000 }
  );
});

describe("sha1", () => {
  test("calculates the correct sha1", async () => {
    const redis = new Redis(client);
    const script = redis.createScript("The quick brown fox jumps over the lazy dog");

    // Wait one tick
    await new Promise((resolve) => setTimeout(resolve, 0));

    expect(script.sha1).toEqual("2fd4e1c67a2d28fced849ee1bb76e7391b93eb12");
  });

  test("calculates the correct sha1 for empty string", async () => {
    const redis = new Redis(client);
    const script = redis.createScript("");

    // Wait one tick
    await new Promise((resolve) => setTimeout(resolve, 0));

    expect(script.sha1).toEqual("da39a3ee5e6b4b0d3255bfef95601890afd80709");
  });
});

describe("script gets loaded", () => {
  test("following evalsha command is a hit", async () => {
    const id = randomID();
    const s = `return "${id}";`;
    const redis = new Redis(client);
    const script = redis.createScript(s);

    let hasThrown = false;

    await script.evalsha([], []).catch(() => {
      hasThrown = true;
    });
    expect(hasThrown).toBeTrue();
    const res = await script.exec([], []);
    expect(res).toEqual(id);

    const res2 = await script.evalsha([], []);
    expect(res2).toEqual(id);
  });
});


================================================================================
# File: script.ts
# Size: 2871 bytes
================================================================================

import { subtle } from "uncrypto";
import type { Redis } from "./redis";
/**
 * Creates a new script.
 *
 * Scripts offer the ability to optimistically try to execute a script without having to send the
 * entire script to the server. If the script is loaded on the server, it tries again by sending
 * the entire script. Afterwards, the script is cached on the server.
 *
 * @example
 * ```ts
 * const redis = new Redis({...})
 *
 * const script = redis.createScript<string>("return ARGV[1];")
 * const arg1 = await script.eval([], ["Hello World"])
 * expect(arg1, "Hello World")
 * ```
 */
export class Script<TResult = unknown> {
  public readonly script: string;
  /**
   * @deprecated This property is initialized to an empty string and will be set in the init method
   * asynchronously. Do not use this property immidiately after the constructor.
   *
   * This property is only exposed for backwards compatibility and will be removed in the
   * future major release.
   */
  public sha1: string;
  private readonly redis: Redis;

  constructor(redis: Redis, script: string) {
    this.redis = redis;
    this.script = script;
    this.sha1 = "";
    void this.init(script);
  }

  /**
   * Initialize the script by computing its SHA-1 hash.
   */
  private async init(script: string): Promise<void> {
    if (this.sha1) return;
    this.sha1 = await this.digest(script);
  }

  /**
   * Send an `EVAL` command to redis.
   */
  public async eval(keys: string[], args: string[]): Promise<TResult> {
    await this.init(this.script);

    return await this.redis.eval(this.script, keys, args);
  }

  /**
   * Calculates the sha1 hash of the script and then calls `EVALSHA`.
   */
  public async evalsha(keys: string[], args: string[]): Promise<TResult> {
    await this.init(this.script);

    return await this.redis.evalsha(this.sha1, keys, args);
  }

  /**
   * Optimistically try to run `EVALSHA` first.
   * If the script is not loaded in redis, it will fall back and try again with `EVAL`.
   *
   * Following calls will be able to use the cached script
   */
  public async exec(keys: string[], args: string[]): Promise<TResult> {
    await this.init(this.script);

    const res = await this.redis.evalsha(this.sha1, keys, args).catch(async (error) => {
      if (error instanceof Error && error.message.toLowerCase().includes("noscript")) {
        return await this.redis.eval(this.script, keys, args);
      }
      throw error;
    });
    return res as TResult;
  }

  /**
   * Compute the sha1 hash of the script and return its hex representation.
   */
  private async digest(s: string): Promise<string> {
    const data = new TextEncoder().encode(s);
    const hashBuffer = await subtle.digest("SHA-1", data);
    const hashArray = [...new Uint8Array(hashBuffer)];
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
}


================================================================================
# File: scriptRo.test.ts
# Size: 1148 bytes
================================================================================

import { afterEach, describe, expect, test } from "bun:test";
import { Redis } from "./redis";
import { keygen, newHttpClient, randomID } from "./test-utils";
const client = newHttpClient();

const { newKey, cleanup } = keygen();
afterEach(cleanup);

describe("create a new readonly script", () => {
  test(
    "creates a new readonly script",
    async () => {
      const redis = new Redis(client);
      const value = randomID();
      const key = newKey();
      await redis.set(key, value);
      const script = redis.createScript("return redis.call('GET', KEYS[1]);", { readonly: true });

      const res = await script.evalRo([key], []);
      expect(res).toEqual(value);
    },
    { timeout: 15_000 }
  );

  test(
    "throws when write commands are used",
    async () => {
      const redis = new Redis(client);
      const value = randomID();
      const key = newKey();
      await redis.set(key, value);
      const script = redis.createScript("return redis.call('DEL', KEYS[1]);", { readonly: true });

      expect(async () => {
        await script.evalRo([key], []);
      }).toThrow();
    },
    { timeout: 15_000 }
  );
});


================================================================================
# File: scriptRo.ts
# Size: 2852 bytes
================================================================================

import { subtle } from "uncrypto";
import type { Redis } from "./redis";

/**
 * Creates a new script.
 *
 * Scripts offer the ability to optimistically try to execute a script without having to send the
 * entire script to the server. If the script is loaded on the server, it tries again by sending
 * the entire script. Afterwards, the script is cached on the server.
 *
 * @example
 * ```ts
 * const redis = new Redis({...})
 *
 * const script = redis.createScript<string>("return ARGV[1];", { readOnly: true })
 * const arg1 = await script.evalRo([], ["Hello World"])
 * expect(arg1, "Hello World")
 * ```
 */
export class ScriptRO<TResult = unknown> {
  public readonly script: string;
  /**
   * @deprecated This property is initialized to an empty string and will be set in the init method
   * asynchronously. Do not use this property immidiately after the constructor.
   *
   * This property is only exposed for backwards compatibility and will be removed in the
   * future major release.
   */
  public sha1: string;
  private readonly redis: Redis;

  constructor(redis: Redis, script: string) {
    this.redis = redis;
    this.sha1 = "";
    this.script = script;
    void this.init(script);
  }

  private async init(script: string): Promise<void> {
    if (this.sha1) return;
    this.sha1 = await this.digest(script);
  }

  /**
   * Send an `EVAL_RO` command to redis.
   */
  public async evalRo(keys: string[], args: string[]): Promise<TResult> {
    await this.init(this.script);

    return await this.redis.evalRo(this.script, keys, args);
  }

  /**
   * Calculates the sha1 hash of the script and then calls `EVALSHA_RO`.
   */
  public async evalshaRo(keys: string[], args: string[]): Promise<TResult> {
    await this.init(this.script);

    return await this.redis.evalshaRo(this.sha1, keys, args);
  }

  /**
   * Optimistically try to run `EVALSHA_RO` first.
   * If the script is not loaded in redis, it will fall back and try again with `EVAL_RO`.
   *
   * Following calls will be able to use the cached script
   */
  public async exec(keys: string[], args: string[]): Promise<TResult> {
    await this.init(this.script);

    const res = await this.redis.evalshaRo(this.sha1, keys, args).catch(async (error) => {
      if (error instanceof Error && error.message.toLowerCase().includes("noscript")) {
        return await this.redis.evalRo(this.script, keys, args);
      }
      throw error;
    });
    return res as TResult;
  }

  /**
   * Compute the sha1 hash of the script and return its hex representation.
   */
  private async digest(s: string): Promise<string> {
    const data = new TextEncoder().encode(s);
    const hashBuffer = await subtle.digest("SHA-1", data);
    const hashArray = [...new Uint8Array(hashBuffer)];
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }
}


================================================================================
# File: test-utils.test.ts
# Size: 671 bytes
================================================================================

import { expect, test } from "bun:test";

import { randomUnsafeIntegerString } from "./test-utils";

test("randomUnsafeIntegerString() should return a string", () => {
  const result = randomUnsafeIntegerString();
  expect(typeof result).toEqual("string");
});
test("randomUnsafeIntegerString() should return different values", () => {
  const result1 = randomUnsafeIntegerString();
  const result2 = randomUnsafeIntegerString();
  expect(result1).not.toEqual(result2);
});
test("randomUnsafeIntegerString() should return a string with unsafe integer", () => {
  const result = randomUnsafeIntegerString();
  expect(Number.isSafeInteger(Number(result))).toBeFalse();
});


================================================================================
# File: test-utils.ts
# Size: 1855 bytes
================================================================================

import { DelCommand } from "./commands/del";
import { XAddCommand } from "./commands/xadd";
import { HttpClient } from "./http";

/**
 * crypto.randomUUID() is not available in dnt crypto shim
 */
export function randomID(): string {
  const bytes = new Uint8Array(32);
  crypto.getRandomValues(bytes);

  const s: string[] = [];
  for (let i = 0; i < bytes.byteLength; i++) {
    s.push(String.fromCodePoint(bytes[i]));
  }
  return btoa(s.join(""));
}
export const randomUnsafeIntegerString = (): string => {
  const buffer = new Uint8Array(8);
  crypto.getRandomValues(buffer);
  const dataView = new DataView(buffer.buffer);
  const unsafeInteger = dataView.getBigInt64(0, true); // true for little-endian
  return unsafeInteger.toString();
};
export const newHttpClient = () => {
  const url = process.env.UPSTASH_REDIS_REST_URL;
  if (!url) {
    throw new Error("Could not find url");
  }
  const token = process.env.UPSTASH_REDIS_REST_TOKEN;
  if (!token) {
    throw new Error("Could not find token");
  }

  return new HttpClient({
    baseUrl: url,
    headers: { authorization: `Bearer ${token}` },
  });
};

export function keygen(): {
  newKey: () => string;
  cleanup: () => Promise<void>;
} {
  const keys: string[] = [];
  return {
    newKey: () => {
      const key = randomID();
      keys.push(key);
      return key;
    },
    cleanup: async () => {
      if (keys.length > 0) {
        await new DelCommand(keys).exec(newHttpClient());
      }
    },
  };
}

export async function addNewItemToStream(streamKey: string, client: HttpClient) {
  const field1 = "field1";
  const member1 = randomID();
  const field2 = "field2";
  const member2 = randomID();

  const res = await new XAddCommand([
    streamKey,
    "*",
    { [field1]: member1, [field2]: member2 },
  ]).exec(client);
  return { member1, member2, streamId: res };
}


================================================================================
# File: types.ts
# Size: 728 bytes
================================================================================

export type CommandArgs<TCommand extends new (..._args: any) => any> =
  ConstructorParameters<TCommand>[0];

export type Telemetry = {
  /**
   * Upstash-Telemetry-Sdk
   * @example @upstash/redis@v1.1.1
   */
  sdk?: string;

  /**
   * Upstash-Telemetry-Platform
   * @example cloudflare
   */
  platform?: string;

  /**
   * Upstash-Telemetry-Runtime
   * @example node@v18
   */
  runtime?: string;
};

export type RedisOptions = {
  /**
   * Automatically try to deserialize the returned data from upstash using `JSON.deserialize`
   *
   * @default true
   */
  automaticDeserialization?: boolean;
  latencyLogging?: boolean;
  enableTelemetry?: boolean;
  enableAutoPipelining?: boolean;
  readYourWrites?: boolean;
};


================================================================================
# File: util.ts
# Size: 2284 bytes
================================================================================

import type { ScanResultWithType } from "./commands/scan";

function parseRecursive(obj: unknown): unknown {
  const parsed = Array.isArray(obj)
    ? obj.map((o) => {
        try {
          return parseRecursive(o);
        } catch {
          return o;
        }
      })
    : JSON.parse(obj as string);

  /**
   * Parsing very large numbers can result in MAX_SAFE_INTEGER
   * overflow. In that case we return the number as string instead.
   */
  if (typeof parsed === "number" && parsed.toString() !== obj) {
    return obj;
  }
  return parsed;
}

export function parseResponse<TResult>(result: unknown): TResult {
  try {
    /**
     * Try to parse the response if possible
     */
    return parseRecursive(result) as TResult;
  } catch {
    return result as TResult;
  }
}

/**
 * Deserializes a scan result, excluding the cursor
 * which can be string "0" or a big number string.
 * Either way, we want it to stay as a string.
 *
 * @param result
 */
export function deserializeScanResponse<TResult>(result: [string, ...any]): TResult {
  return [result[0], ...parseResponse<any[]>(result.slice(1))] as TResult;
}

export function deserializeScanWithTypesResponse(result: [string, string[]]): ScanResultWithType {
  const [cursor, keys] = result;

  const parsedKeys: ScanResultWithType[1] = [];

  for (let i = 0; i < keys.length; i += 2) {
    parsedKeys.push({ key: keys[i], type: keys[i + 1] });
  }

  return [cursor, parsedKeys];
}

/**
 * Merges multiple Records of headers into a single Record
 * Later headers take precedence over earlier ones.
 *
 * @param headers - Array of header records to merge
 * @returns A new Record containing all merged headers
 *
 * @example
 * const defaultHeaders = { 'Content-Type': 'application/json' };
 * const customHeaders = { 'Authorization': 'Bearer token' };
 * const merged = mergeHeaders(defaultHeaders, customHeaders);
 */
export function mergeHeaders(
  ...headers: (Record<string, string> | undefined)[]
): Record<string, string> {
  const merged: Record<string, string> = {};

  for (const header of headers) {
    if (!header) continue;

    for (const [key, value] of Object.entries(header)) {
      if (value !== undefined && value !== null) {
        merged[key] = value;
      }
    }
  }

  return merged;
}
